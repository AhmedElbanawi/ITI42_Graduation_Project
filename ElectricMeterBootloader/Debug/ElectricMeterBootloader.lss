
ElectricMeterBootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000007f8  00007000  00007000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  000077f8  000008ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000018d  008000a8  008000a8  000008f4  2**0
                  ALLOC
  3 .eeprom       00000002  00810000  00810000  000008f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000021c0  00000000  00000000  000008f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00001545  00000000  00000000  00002ab8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 2a 38 	jmp	0x7054	; 0x7054 <__ctors_end>
    7004:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7008:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    700c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7010:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7014:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7018:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    701c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7020:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7024:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7028:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    702c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7030:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7034:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7038:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    703c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7040:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7044:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7048:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    704c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7050:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>

00007054 <__ctors_end>:
    7054:	11 24       	eor	r1, r1
    7056:	1f be       	out	0x3f, r1	; 63
    7058:	cf e5       	ldi	r28, 0x5F	; 95
    705a:	d8 e0       	ldi	r29, 0x08	; 8
    705c:	de bf       	out	0x3e, r29	; 62
    705e:	cd bf       	out	0x3d, r28	; 61

00007060 <__do_copy_data>:
    7060:	10 e0       	ldi	r17, 0x00	; 0
    7062:	a0 e6       	ldi	r26, 0x60	; 96
    7064:	b0 e0       	ldi	r27, 0x00	; 0
    7066:	e8 ef       	ldi	r30, 0xF8	; 248
    7068:	f7 e7       	ldi	r31, 0x77	; 119
    706a:	02 c0       	rjmp	.+4      	; 0x7070 <.do_copy_data_start>

0000706c <.do_copy_data_loop>:
    706c:	05 90       	lpm	r0, Z+
    706e:	0d 92       	st	X+, r0

00007070 <.do_copy_data_start>:
    7070:	a8 3a       	cpi	r26, 0xA8	; 168
    7072:	b1 07       	cpc	r27, r17
    7074:	d9 f7       	brne	.-10     	; 0x706c <.do_copy_data_loop>

00007076 <__do_clear_bss>:
    7076:	12 e0       	ldi	r17, 0x02	; 2
    7078:	a8 ea       	ldi	r26, 0xA8	; 168
    707a:	b0 e0       	ldi	r27, 0x00	; 0
    707c:	01 c0       	rjmp	.+2      	; 0x7080 <.do_clear_bss_start>

0000707e <.do_clear_bss_loop>:
    707e:	1d 92       	st	X+, r1

00007080 <.do_clear_bss_start>:
    7080:	a5 33       	cpi	r26, 0x35	; 53
    7082:	b1 07       	cpc	r27, r17
    7084:	e1 f7       	brne	.-8      	; 0x707e <.do_clear_bss_loop>
    7086:	0e 94 ae 3b 	call	0x775c	; 0x775c <main>
    708a:	0c 94 fa 3b 	jmp	0x77f4	; 0x77f4 <_exit>

0000708e <__bad_interrupt>:
    708e:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

00007092 <Display_Record>:
    7092:	1f 93       	push	r17
    7094:	80 91 a8 00 	lds	r24, 0x00A8
    7098:	90 91 a9 00 	lds	r25, 0x00A9
    709c:	89 2b       	or	r24, r25
    709e:	b1 f0       	breq	.+44     	; 0x70cc <Display_Record+0x3a>
    70a0:	10 e0       	ldi	r17, 0x00	; 0
    70a2:	e0 91 a8 00 	lds	r30, 0x00A8
    70a6:	f0 91 a9 00 	lds	r31, 0x00A9
    70aa:	e1 0f       	add	r30, r17
    70ac:	f1 1d       	adc	r31, r1
    70ae:	80 81       	ld	r24, Z
    70b0:	0e 94 7f 3b 	call	0x76fe	; 0x76fe <URT_Tx_Char>
    70b4:	1f 5f       	subi	r17, 0xFF	; 255
    70b6:	e0 91 a8 00 	lds	r30, 0x00A8
    70ba:	f0 91 a9 00 	lds	r31, 0x00A9
    70be:	e1 0f       	add	r30, r17
    70c0:	f1 1d       	adc	r31, r1
    70c2:	80 81       	ld	r24, Z
    70c4:	8e 32       	cpi	r24, 0x2E	; 46
    70c6:	69 f7       	brne	.-38     	; 0x70a2 <Display_Record+0x10>
    70c8:	0e 94 7f 3b 	call	0x76fe	; 0x76fe <URT_Tx_Char>
    70cc:	1f 91       	pop	r17
    70ce:	08 95       	ret

000070d0 <APP_Rx>:
BOOL_t
APP_Rx(void){

	BOOL_t Finished=FALSE;

	switch(App_State_Download){
    70d0:	80 91 aa 00 	lds	r24, 0x00AA
    70d4:	81 30       	cpi	r24, 0x01	; 1
    70d6:	79 f0       	breq	.+30     	; 0x70f6 <APP_Rx+0x26>
    70d8:	81 30       	cpi	r24, 0x01	; 1
    70da:	28 f0       	brcs	.+10     	; 0x70e6 <APP_Rx+0x16>
    70dc:	82 30       	cpi	r24, 0x02	; 2
    70de:	d1 f0       	breq	.+52     	; 0x7114 <APP_Rx+0x44>
    70e0:	83 30       	cpi	r24, 0x03	; 3
    70e2:	51 f5       	brne	.+84     	; 0x7138 <APP_Rx+0x68>
    70e4:	2b c0       	rjmp	.+86     	; 0x713c <APP_Rx+0x6c>

	case RECEVING_RECORD:
		Current_Record=RECORD_Get();
    70e6:	0e 94 11 3b 	call	0x7622	; 0x7622 <RECORD_Get>
    70ea:	90 93 a9 00 	sts	0x00A9, r25
    70ee:	80 93 a8 00 	sts	0x00A8, r24
		App_State_Download=CHECKING_RECORD_CRC;
    70f2:	81 e0       	ldi	r24, 0x01	; 1
    70f4:	1a c0       	rjmp	.+52     	; 0x712a <APP_Rx+0x5a>
		//Display_Record();
		break;

	case CHECKING_RECORD_CRC:
		if(TRUE==CRC_Check(Current_Record)){
    70f6:	80 91 a8 00 	lds	r24, 0x00A8
    70fa:	90 91 a9 00 	lds	r25, 0x00A9
    70fe:	0e 94 08 39 	call	0x7210	; 0x7210 <CRC_Check>
    7102:	81 30       	cpi	r24, 0x01	; 1
    7104:	11 f4       	brne	.+4      	; 0x710a <APP_Rx+0x3a>
			App_State_Download=STORING_RECORD_WITH_PAGING;
    7106:	82 e0       	ldi	r24, 0x02	; 2
    7108:	10 c0       	rjmp	.+32     	; 0x712a <APP_Rx+0x5a>
		}else {
			App_State_Download=RECEVING_RECORD;
    710a:	10 92 aa 00 	sts	0x00AA, r1
			UDS_Send_Negative_Response();
    710e:	0e 94 26 3b 	call	0x764c	; 0x764c <UDS_Send_Negative_Response>
    7112:	12 c0       	rjmp	.+36     	; 0x7138 <APP_Rx+0x68>
		}
			break;

	case STORING_RECORD_WITH_PAGING:
		if(TRUE==PARSER_Record(App, Current_Record)){
    7114:	60 91 a8 00 	lds	r22, 0x00A8
    7118:	70 91 a9 00 	lds	r23, 0x00A9
    711c:	8b ea       	ldi	r24, 0xAB	; 171
    711e:	90 e0       	ldi	r25, 0x00	; 0
    7120:	0e 94 8d 3a 	call	0x751a	; 0x751a <PARSER_Record>
    7124:	81 30       	cpi	r24, 0x01	; 1
    7126:	21 f4       	brne	.+8      	; 0x7130 <APP_Rx+0x60>
			App_State_Download=APP_DOWNLOADING_ENDED;
    7128:	83 e0       	ldi	r24, 0x03	; 3
    712a:	80 93 aa 00 	sts	0x00AA, r24
    712e:	04 c0       	rjmp	.+8      	; 0x7138 <APP_Rx+0x68>
		}else {
			App_State_Download=RECEVING_RECORD;
    7130:	10 92 aa 00 	sts	0x00AA, r1
			UDS_Send_Positive_Response();
    7134:	0e 94 2a 3b 	call	0x7654	; 0x7654 <UDS_Send_Positive_Response>
    7138:	80 e0       	ldi	r24, 0x00	; 0
    713a:	08 95       	ret
		}
			break;

	case APP_DOWNLOADING_ENDED:
		Finished=TRUE;
		UDS_Send_Positive_Response();
    713c:	0e 94 2a 3b 	call	0x7654	; 0x7654 <UDS_Send_Positive_Response>
    7140:	81 e0       	ldi	r24, 0x01	; 1
			break;

	}
	return Finished;
}
    7142:	08 95       	ret

00007144 <APP_Read_State>:

	APP_STATE_t State = APP_NOT_EXIST;

	UINT8_t Reading;

	Reading = FLASH_Data_Read(APP_UPDATE_ADDRESS);
    7144:	80 e0       	ldi	r24, 0x00	; 0
    7146:	90 e0       	ldi	r25, 0x00	; 0
    7148:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <FLASH_Data_Read>
    714c:	20 e1       	ldi	r18, 0x10	; 16
    714e:	37 e2       	ldi	r19, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7150:	48 ec       	ldi	r20, 0xC8	; 200
    7152:	50 e0       	ldi	r21, 0x00	; 0
    7154:	fa 01       	movw	r30, r20
    7156:	31 97       	sbiw	r30, 0x01	; 1
    7158:	f1 f7       	brne	.-4      	; 0x7156 <APP_Read_State+0x12>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    715a:	21 50       	subi	r18, 0x01	; 1
    715c:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    715e:	d1 f7       	brne	.-12     	; 0x7154 <APP_Read_State+0x10>

	_delay_ms(1000);

	switch (Reading) {
    7160:	80 39       	cpi	r24, 0x90	; 144
    7162:	11 f4       	brne	.+4      	; 0x7168 <APP_Read_State+0x24>
    7164:	80 e9       	ldi	r24, 0x90	; 144
    7166:	08 95       	ret
    7168:	80 e7       	ldi	r24, 0x70	; 112
	default:

		break;
	}
	return State;
}
    716a:	08 95       	ret

0000716c <APP_Write_State>:
static UINT8_t App[PAGE_SIZE];

void
APP_Write_State(APP_STATE_t State){

	switch(State){
    716c:	80 37       	cpi	r24, 0x70	; 112
    716e:	19 f0       	breq	.+6      	; 0x7176 <APP_Write_State+0xa>
    7170:	80 39       	cpi	r24, 0x90	; 144
    7172:	51 f4       	brne	.+20     	; 0x7188 <APP_Write_State+0x1c>
    7174:	04 c0       	rjmp	.+8      	; 0x717e <APP_Write_State+0x12>

	case APP_NOT_EXIST:
		FLASH_Data_Write(APP_UPDATE_ADDRESS, APP_NOT_EXIST);
    7176:	80 e0       	ldi	r24, 0x00	; 0
    7178:	90 e0       	ldi	r25, 0x00	; 0
    717a:	60 e7       	ldi	r22, 0x70	; 112
    717c:	03 c0       	rjmp	.+6      	; 0x7184 <APP_Write_State+0x18>
		break;

	case APP_EXIST:
		FLASH_Data_Write(APP_UPDATE_ADDRESS, APP_EXIST);
    717e:	80 e0       	ldi	r24, 0x00	; 0
    7180:	90 e0       	ldi	r25, 0x00	; 0
    7182:	60 e9       	ldi	r22, 0x90	; 144
    7184:	0e 94 6c 3a 	call	0x74d8	; 0x74d8 <FLASH_Data_Write>
    7188:	80 e1       	ldi	r24, 0x10	; 16
    718a:	97 e2       	ldi	r25, 0x27	; 39
    718c:	28 ec       	ldi	r18, 0xC8	; 200
    718e:	30 e0       	ldi	r19, 0x00	; 0
    7190:	f9 01       	movw	r30, r18
    7192:	31 97       	sbiw	r30, 0x01	; 1
    7194:	f1 f7       	brne	.-4      	; 0x7192 <APP_Write_State+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7196:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7198:	d9 f7       	brne	.-10     	; 0x7190 <APP_Write_State+0x24>

	}

	_delay_ms(1000);

}
    719a:	08 95       	ret

0000719c <Asci2Hex>:
}


UINT8_t
Asci2Hex(UINT8_t MSB4, UINT8_t LSB4)
{
    719c:	98 2f       	mov	r25, r24
	UINT8_t Hex=0;
	if( (MSB4 >='0' && MSB4 <='9') && (LSB4 >='0' && LSB4 <='9') ){
    719e:	80 53       	subi	r24, 0x30	; 48
    71a0:	26 2f       	mov	r18, r22
    71a2:	20 53       	subi	r18, 0x30	; 48
    71a4:	8a 30       	cpi	r24, 0x0A	; 10
    71a6:	78 f4       	brcc	.+30     	; 0x71c6 <Asci2Hex+0x2a>
    71a8:	2a 30       	cpi	r18, 0x0A	; 10
    71aa:	20 f4       	brcc	.+8      	; 0x71b4 <Asci2Hex+0x18>
		Hex= ( (MSB4-'0')<<4 ) | (LSB4-'0');
    71ac:	92 95       	swap	r25
    71ae:	90 7f       	andi	r25, 0xF0	; 240
    71b0:	92 2b       	or	r25, r18
    71b2:	2c c0       	rjmp	.+88     	; 0x720c <Asci2Hex+0x70>
	}else if( (MSB4 >='0' && MSB4 <='9') ){
		if(LSB4 >='A' && LSB4 <='Z'){
    71b4:	86 2f       	mov	r24, r22
    71b6:	81 54       	subi	r24, 0x41	; 65
    71b8:	8a 31       	cpi	r24, 0x1A	; 26
    71ba:	38 f5       	brcc	.+78     	; 0x720a <Asci2Hex+0x6e>
			Hex= ( (MSB4-'0')<<4 ) | (LSB4-'A'+10);
    71bc:	92 95       	swap	r25
    71be:	90 7f       	andi	r25, 0xF0	; 240
    71c0:	67 53       	subi	r22, 0x37	; 55
    71c2:	96 2b       	or	r25, r22
    71c4:	23 c0       	rjmp	.+70     	; 0x720c <Asci2Hex+0x70>
    71c6:	89 2f       	mov	r24, r25
    71c8:	81 54       	subi	r24, 0x41	; 65
		}
	}else if( (LSB4 >='0' && LSB4 <='9') ){
    71ca:	2a 30       	cpi	r18, 0x0A	; 10
    71cc:	60 f4       	brcc	.+24     	; 0x71e6 <Asci2Hex+0x4a>
		if(MSB4 >='A' && MSB4 <='Z'){
    71ce:	8a 31       	cpi	r24, 0x1A	; 26
    71d0:	e0 f4       	brcc	.+56     	; 0x720a <Asci2Hex+0x6e>
			Hex= ( (MSB4-'A'+10)<<4 ) | (LSB4-'0');
    71d2:	89 2f       	mov	r24, r25
    71d4:	90 e0       	ldi	r25, 0x00	; 0
    71d6:	c7 97       	sbiw	r24, 0x37	; 55
    71d8:	34 e0       	ldi	r19, 0x04	; 4
    71da:	88 0f       	add	r24, r24
    71dc:	99 1f       	adc	r25, r25
    71de:	3a 95       	dec	r19
    71e0:	e1 f7       	brne	.-8      	; 0x71da <Asci2Hex+0x3e>
    71e2:	92 2f       	mov	r25, r18
    71e4:	10 c0       	rjmp	.+32     	; 0x7206 <Asci2Hex+0x6a>
		}
	}else if( (MSB4 >='A' && MSB4 <='Z') && (LSB4 >='A' && LSB4 <='Z') ){
    71e6:	8a 31       	cpi	r24, 0x1A	; 26
    71e8:	80 f4       	brcc	.+32     	; 0x720a <Asci2Hex+0x6e>
    71ea:	86 2f       	mov	r24, r22
    71ec:	81 54       	subi	r24, 0x41	; 65
    71ee:	8a 31       	cpi	r24, 0x1A	; 26
    71f0:	60 f4       	brcc	.+24     	; 0x720a <Asci2Hex+0x6e>
		Hex= ( (MSB4-'A'+10)<<4 ) | (LSB4-'A'+10);
    71f2:	89 2f       	mov	r24, r25
    71f4:	90 e0       	ldi	r25, 0x00	; 0
    71f6:	c7 97       	sbiw	r24, 0x37	; 55
    71f8:	24 e0       	ldi	r18, 0x04	; 4
    71fa:	88 0f       	add	r24, r24
    71fc:	99 1f       	adc	r25, r25
    71fe:	2a 95       	dec	r18
    7200:	e1 f7       	brne	.-8      	; 0x71fa <Asci2Hex+0x5e>
    7202:	96 2f       	mov	r25, r22
    7204:	97 53       	subi	r25, 0x37	; 55
    7206:	98 2b       	or	r25, r24
    7208:	01 c0       	rjmp	.+2      	; 0x720c <Asci2Hex+0x70>
    720a:	90 e0       	ldi	r25, 0x00	; 0
	}else {

	}
	return Hex;
}
    720c:	89 2f       	mov	r24, r25
    720e:	08 95       	ret

00007210 <CRC_Check>:
#include "STD_BITS.h"
#include "CRC.h"

BOOL_t
CRC_Check(UINT8_t*Record)
{
    7210:	af 92       	push	r10
    7212:	bf 92       	push	r11
    7214:	cf 92       	push	r12
    7216:	df 92       	push	r13
    7218:	ef 92       	push	r14
    721a:	ff 92       	push	r15
    721c:	0f 93       	push	r16
    721e:	1f 93       	push	r17
    7220:	cf 93       	push	r28
    7222:	df 93       	push	r29
    7224:	5c 01       	movw	r10, r24
    7226:	ec 01       	movw	r28, r24
    7228:	ee 24       	eor	r14, r14
    722a:	ff 24       	eor	r15, r15
    722c:	87 01       	movw	r16, r14
    722e:	e0 e0       	ldi	r30, 0x00	; 0
    7230:	f0 e0       	ldi	r31, 0x00	; 0
    7232:	0a c0       	rjmp	.+20     	; 0x7248 <CRC_Check+0x38>
	UINT32_t Sum = 0;
	UINT16_t Idx = 0;
	UINT8_t Curr_Crc;

	while (Record[Idx + 2] != STOP_CHAR) {
		Sum += Asci2Hex(Record[Idx], Record[1 + Idx]);
    7234:	88 81       	ld	r24, Y
    7236:	69 81       	ldd	r22, Y+1	; 0x01
    7238:	0e 94 ce 38 	call	0x719c	; 0x719c <Asci2Hex>
    723c:	e8 0e       	add	r14, r24
    723e:	f1 1c       	adc	r15, r1
    7240:	01 1d       	adc	r16, r1
    7242:	11 1d       	adc	r17, r1
    7244:	22 96       	adiw	r28, 0x02	; 2
    7246:	f6 01       	movw	r30, r12
	BOOL_t State = FALSE;
	UINT32_t Sum = 0;
	UINT16_t Idx = 0;
	UINT8_t Curr_Crc;

	while (Record[Idx + 2] != STOP_CHAR) {
    7248:	42 e0       	ldi	r20, 0x02	; 2
    724a:	c4 2e       	mov	r12, r20
    724c:	d1 2c       	mov	r13, r1
    724e:	ce 0e       	add	r12, r30
    7250:	df 1e       	adc	r13, r31
    7252:	8a 81       	ldd	r24, Y+2	; 0x02
    7254:	8e 32       	cpi	r24, 0x2E	; 46
    7256:	71 f7       	brne	.-36     	; 0x7234 <CRC_Check+0x24>
		Sum += Asci2Hex(Record[Idx], Record[1 + Idx]);
		Idx += 2;
	}
	Sum &= 0xff;
	Curr_Crc = 0x100UL - Sum;
	if (Curr_Crc == Asci2Hex(Record[Idx], Record[1 + Idx])) {
    7258:	ea 0d       	add	r30, r10
    725a:	fb 1d       	adc	r31, r11
    725c:	80 81       	ld	r24, Z
    725e:	61 81       	ldd	r22, Z+1	; 0x01
    7260:	0e 94 ce 38 	call	0x719c	; 0x719c <Asci2Hex>
    7264:	20 e0       	ldi	r18, 0x00	; 0
    7266:	9e 2d       	mov	r25, r14
    7268:	91 95       	neg	r25
    726a:	98 17       	cp	r25, r24
    726c:	09 f4       	brne	.+2      	; 0x7270 <CRC_Check+0x60>
    726e:	21 e0       	ldi	r18, 0x01	; 1
		State = TRUE;
	}

	return State;

}
    7270:	82 2f       	mov	r24, r18
    7272:	df 91       	pop	r29
    7274:	cf 91       	pop	r28
    7276:	1f 91       	pop	r17
    7278:	0f 91       	pop	r16
    727a:	ff 90       	pop	r15
    727c:	ef 90       	pop	r14
    727e:	df 90       	pop	r13
    7280:	cf 90       	pop	r12
    7282:	bf 90       	pop	r11
    7284:	af 90       	pop	r10
    7286:	08 95       	ret

00007288 <DIO_WRITE_PIN_VALUE>:
			break;
		}
	}
}
/****************************************************************************/
void DIO_WRITE_PIN_VALUE(const DIO_PIN_ID_t PIN_ID, const DIO_PIN_STATE_t PIN_STATE){
    7288:	38 2f       	mov	r19, r24
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { PORTA_ADD, PORTB_ADD, PORTC_ADD, PORTD_ADD };
	DIO_PORT_ID_t Port_Id = PIN_ID / 8;
    728a:	e8 2f       	mov	r30, r24
    728c:	e6 95       	lsr	r30
    728e:	e6 95       	lsr	r30
    7290:	e6 95       	lsr	r30
	switch (PIN_STATE) {
    7292:	66 23       	and	r22, r22
    7294:	b1 f0       	breq	.+44     	; 0x72c2 <DIO_WRITE_PIN_VALUE+0x3a>
    7296:	61 30       	cpi	r22, 0x01	; 1
    7298:	41 f5       	brne	.+80     	; 0x72ea <DIO_WRITE_PIN_VALUE+0x62>
	case DIO_PIN_STATE_HIGH:
		SET_BIT(*Reg[Port_Id], PIN_ID % 8);
    729a:	f0 e0       	ldi	r31, 0x00	; 0
    729c:	ee 0f       	add	r30, r30
    729e:	ff 1f       	adc	r31, r31
    72a0:	e8 56       	subi	r30, 0x68	; 104
    72a2:	ff 4f       	sbci	r31, 0xFF	; 255
    72a4:	01 90       	ld	r0, Z+
    72a6:	f0 81       	ld	r31, Z
    72a8:	e0 2d       	mov	r30, r0
    72aa:	20 81       	ld	r18, Z
    72ac:	37 70       	andi	r19, 0x07	; 7
    72ae:	81 e0       	ldi	r24, 0x01	; 1
    72b0:	90 e0       	ldi	r25, 0x00	; 0
    72b2:	02 c0       	rjmp	.+4      	; 0x72b8 <DIO_WRITE_PIN_VALUE+0x30>
    72b4:	88 0f       	add	r24, r24
    72b6:	99 1f       	adc	r25, r25
    72b8:	3a 95       	dec	r19
    72ba:	e2 f7       	brpl	.-8      	; 0x72b4 <DIO_WRITE_PIN_VALUE+0x2c>
    72bc:	28 2b       	or	r18, r24
    72be:	20 83       	st	Z, r18
    72c0:	08 95       	ret
		break;
	case DIO_PIN_STATE_LOW:
		CLEAR_BIT(*Reg[Port_Id], PIN_ID % 8);
    72c2:	f0 e0       	ldi	r31, 0x00	; 0
    72c4:	ee 0f       	add	r30, r30
    72c6:	ff 1f       	adc	r31, r31
    72c8:	e8 56       	subi	r30, 0x68	; 104
    72ca:	ff 4f       	sbci	r31, 0xFF	; 255
    72cc:	01 90       	ld	r0, Z+
    72ce:	f0 81       	ld	r31, Z
    72d0:	e0 2d       	mov	r30, r0
    72d2:	20 81       	ld	r18, Z
    72d4:	37 70       	andi	r19, 0x07	; 7
    72d6:	81 e0       	ldi	r24, 0x01	; 1
    72d8:	90 e0       	ldi	r25, 0x00	; 0
    72da:	02 c0       	rjmp	.+4      	; 0x72e0 <DIO_WRITE_PIN_VALUE+0x58>
    72dc:	88 0f       	add	r24, r24
    72de:	99 1f       	adc	r25, r25
    72e0:	3a 95       	dec	r19
    72e2:	e2 f7       	brpl	.-8      	; 0x72dc <DIO_WRITE_PIN_VALUE+0x54>
    72e4:	80 95       	com	r24
    72e6:	82 23       	and	r24, r18
    72e8:	80 83       	st	Z, r24
    72ea:	08 95       	ret

000072ec <DIO_INIT>:
#include "DIO_CFG.h"
#include "DIO.h"
/****************************************************************************/

void DIO_INIT(void)
{
    72ec:	ef 92       	push	r14
    72ee:	ff 92       	push	r15
    72f0:	1f 93       	push	r17
    72f2:	cf 93       	push	r28
    72f4:	df 93       	push	r29
    72f6:	10 e0       	ldi	r17, 0x00	; 0
    72f8:	c0 e0       	ldi	r28, 0x00	; 0
    72fa:	d0 e0       	ldi	r29, 0x00	; 0
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { DDRA_ADD, DDRB_ADD, DDRC_ADD, DDRD_ADD };
	for (Pin_Id = DIO_PINA0; Pin_Id < DIO_MAX_PINS; Pin_Id++) {
		Port_Id = Pin_Id / 8;
		switch (Pin_Direction[Pin_Id]) {
		case DIO_PIN_DIRECTION_OUTPUT:
			SET_BIT(*Reg[Port_Id], Pin_Id % 8);
    72fc:	51 e0       	ldi	r21, 0x01	; 1
    72fe:	e5 2e       	mov	r14, r21
    7300:	f1 2c       	mov	r15, r1
{
	DIO_PIN_ID_t Pin_Id;
	DIO_PORT_ID_t Port_Id;
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { DDRA_ADD, DDRB_ADD, DDRC_ADD, DDRD_ADD };
	for (Pin_Id = DIO_PINA0; Pin_Id < DIO_MAX_PINS; Pin_Id++) {
		Port_Id = Pin_Id / 8;
    7302:	21 2f       	mov	r18, r17
    7304:	26 95       	lsr	r18
    7306:	26 95       	lsr	r18
    7308:	26 95       	lsr	r18
		switch (Pin_Direction[Pin_Id]) {
    730a:	81 2f       	mov	r24, r17
    730c:	90 e0       	ldi	r25, 0x00	; 0
    730e:	fc 01       	movw	r30, r24
    7310:	e0 5a       	subi	r30, 0xA0	; 160
    7312:	ff 4f       	sbci	r31, 0xFF	; 255
    7314:	e0 81       	ld	r30, Z
    7316:	e1 30       	cpi	r30, 0x01	; 1
    7318:	31 f0       	breq	.+12     	; 0x7326 <DIO_INIT+0x3a>
    731a:	e1 30       	cpi	r30, 0x01	; 1
    731c:	c8 f0       	brcs	.+50     	; 0x7350 <DIO_INIT+0x64>
    731e:	e2 30       	cpi	r30, 0x02	; 2
    7320:	09 f0       	breq	.+2      	; 0x7324 <DIO_INIT+0x38>
    7322:	49 c0       	rjmp	.+146    	; 0x73b6 <DIO_INIT+0xca>
    7324:	2e c0       	rjmp	.+92     	; 0x7382 <DIO_INIT+0x96>
		case DIO_PIN_DIRECTION_OUTPUT:
			SET_BIT(*Reg[Port_Id], Pin_Id % 8);
    7326:	e2 2f       	mov	r30, r18
    7328:	f0 e0       	ldi	r31, 0x00	; 0
    732a:	ee 0f       	add	r30, r30
    732c:	ff 1f       	adc	r31, r31
    732e:	e0 56       	subi	r30, 0x60	; 96
    7330:	ff 4f       	sbci	r31, 0xFF	; 255
    7332:	01 90       	ld	r0, Z+
    7334:	f0 81       	ld	r31, Z
    7336:	e0 2d       	mov	r30, r0
    7338:	20 81       	ld	r18, Z
    733a:	87 70       	andi	r24, 0x07	; 7
    733c:	90 70       	andi	r25, 0x00	; 0
    733e:	a7 01       	movw	r20, r14
    7340:	02 c0       	rjmp	.+4      	; 0x7346 <DIO_INIT+0x5a>
    7342:	44 0f       	add	r20, r20
    7344:	55 1f       	adc	r21, r21
    7346:	8a 95       	dec	r24
    7348:	e2 f7       	brpl	.-8      	; 0x7342 <DIO_INIT+0x56>
    734a:	24 2b       	or	r18, r20
    734c:	20 83       	st	Z, r18
    734e:	33 c0       	rjmp	.+102    	; 0x73b6 <DIO_INIT+0xca>
			break;
		case DIO_PIN_DIRECTION_INPUT_PULL_UP:
			CLEAR_BIT(*Reg[Port_Id], Pin_Id % 8);
    7350:	e2 2f       	mov	r30, r18
    7352:	f0 e0       	ldi	r31, 0x00	; 0
    7354:	ee 0f       	add	r30, r30
    7356:	ff 1f       	adc	r31, r31
    7358:	e0 56       	subi	r30, 0x60	; 96
    735a:	ff 4f       	sbci	r31, 0xFF	; 255
    735c:	01 90       	ld	r0, Z+
    735e:	f0 81       	ld	r31, Z
    7360:	e0 2d       	mov	r30, r0
    7362:	20 81       	ld	r18, Z
    7364:	87 70       	andi	r24, 0x07	; 7
    7366:	90 70       	andi	r25, 0x00	; 0
    7368:	a7 01       	movw	r20, r14
    736a:	02 c0       	rjmp	.+4      	; 0x7370 <DIO_INIT+0x84>
    736c:	44 0f       	add	r20, r20
    736e:	55 1f       	adc	r21, r21
    7370:	8a 95       	dec	r24
    7372:	e2 f7       	brpl	.-8      	; 0x736c <DIO_INIT+0x80>
    7374:	ca 01       	movw	r24, r20
    7376:	80 95       	com	r24
    7378:	82 23       	and	r24, r18
    737a:	80 83       	st	Z, r24
			DIO_WRITE_PIN_VALUE(Pin_Id, DIO_PIN_STATE_HIGH);
    737c:	81 2f       	mov	r24, r17
    737e:	61 e0       	ldi	r22, 0x01	; 1
    7380:	18 c0       	rjmp	.+48     	; 0x73b2 <DIO_INIT+0xc6>
			break;
		case DIO_PIN_DIRECTION_INPUT_FLOAT:
			CLEAR_BIT(*Reg[Port_Id], Pin_Id % 8);
    7382:	e2 2f       	mov	r30, r18
    7384:	f0 e0       	ldi	r31, 0x00	; 0
    7386:	ee 0f       	add	r30, r30
    7388:	ff 1f       	adc	r31, r31
    738a:	e0 56       	subi	r30, 0x60	; 96
    738c:	ff 4f       	sbci	r31, 0xFF	; 255
    738e:	01 90       	ld	r0, Z+
    7390:	f0 81       	ld	r31, Z
    7392:	e0 2d       	mov	r30, r0
    7394:	20 81       	ld	r18, Z
    7396:	87 70       	andi	r24, 0x07	; 7
    7398:	90 70       	andi	r25, 0x00	; 0
    739a:	a7 01       	movw	r20, r14
    739c:	02 c0       	rjmp	.+4      	; 0x73a2 <DIO_INIT+0xb6>
    739e:	44 0f       	add	r20, r20
    73a0:	55 1f       	adc	r21, r21
    73a2:	8a 95       	dec	r24
    73a4:	e2 f7       	brpl	.-8      	; 0x739e <DIO_INIT+0xb2>
    73a6:	ca 01       	movw	r24, r20
    73a8:	80 95       	com	r24
    73aa:	82 23       	and	r24, r18
    73ac:	80 83       	st	Z, r24
			DIO_WRITE_PIN_VALUE(Pin_Id, DIO_PIN_STATE_LOW);
    73ae:	81 2f       	mov	r24, r17
    73b0:	60 e0       	ldi	r22, 0x00	; 0
    73b2:	0e 94 44 39 	call	0x7288	; 0x7288 <DIO_WRITE_PIN_VALUE>
void DIO_INIT(void)
{
	DIO_PIN_ID_t Pin_Id;
	DIO_PORT_ID_t Port_Id;
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { DDRA_ADD, DDRB_ADD, DDRC_ADD, DDRD_ADD };
	for (Pin_Id = DIO_PINA0; Pin_Id < DIO_MAX_PINS; Pin_Id++) {
    73b6:	1f 5f       	subi	r17, 0xFF	; 255
    73b8:	21 96       	adiw	r28, 0x01	; 1
    73ba:	c0 32       	cpi	r28, 0x20	; 32
    73bc:	d1 05       	cpc	r29, r1
    73be:	09 f0       	breq	.+2      	; 0x73c2 <DIO_INIT+0xd6>
    73c0:	a0 cf       	rjmp	.-192    	; 0x7302 <DIO_INIT+0x16>
		break;
		default:
			break;
		}
	}
}
    73c2:	df 91       	pop	r29
    73c4:	cf 91       	pop	r28
    73c6:	1f 91       	pop	r17
    73c8:	ff 90       	pop	r15
    73ca:	ef 90       	pop	r14
    73cc:	08 95       	ret

000073ce <DIO_READ_PIN_VALUE>:
	default:
		break;
	}
}
/****************************************************************************/
DIO_PIN_STATE_t DIO_READ_PIN_VALUE(const DIO_PIN_ID_t PIN_ID){
    73ce:	28 2f       	mov	r18, r24
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { PINA_ADD, PINB_ADD, PINC_ADD, PIND_ADD };
	DIO_PORT_ID_t Port_Id = PIN_ID / 8;
	DIO_PIN_STATE_t State = DIO_PIN_STATE_LOW;
	if(DIO_PIN_STATE_HIGH == GET_BIT(*Reg[Port_Id], PIN_ID % 8)){
    73d0:	e8 2f       	mov	r30, r24
    73d2:	e6 95       	lsr	r30
    73d4:	e6 95       	lsr	r30
    73d6:	e6 95       	lsr	r30
    73d8:	f0 e0       	ldi	r31, 0x00	; 0
    73da:	ee 0f       	add	r30, r30
    73dc:	ff 1f       	adc	r31, r31
    73de:	e0 57       	subi	r30, 0x70	; 112
    73e0:	ff 4f       	sbci	r31, 0xFF	; 255
    73e2:	01 90       	ld	r0, Z+
    73e4:	f0 81       	ld	r31, Z
    73e6:	e0 2d       	mov	r30, r0
    73e8:	80 81       	ld	r24, Z
    73ea:	90 e0       	ldi	r25, 0x00	; 0
    73ec:	27 70       	andi	r18, 0x07	; 7
    73ee:	02 c0       	rjmp	.+4      	; 0x73f4 <DIO_READ_PIN_VALUE+0x26>
    73f0:	95 95       	asr	r25
    73f2:	87 95       	ror	r24
    73f4:	2a 95       	dec	r18
    73f6:	e2 f7       	brpl	.-8      	; 0x73f0 <DIO_READ_PIN_VALUE+0x22>
		State = DIO_PIN_STATE_HIGH;
	}
	return State;
}
    73f8:	81 70       	andi	r24, 0x01	; 1
    73fa:	08 95       	ret

000073fc <DIO_WRITE_PORT>:
/****************************************************************************/
void DIO_WRITE_PORT(const DIO_PORT_ID_t PORT_ID, const UINT8_t VALUE){
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { PORTA_ADD, PORTB_ADD, PORTC_ADD, PORTD_ADD };
	*Reg[PORT_ID] = VALUE;
    73fc:	e8 2f       	mov	r30, r24
    73fe:	f0 e0       	ldi	r31, 0x00	; 0
    7400:	ee 0f       	add	r30, r30
    7402:	ff 1f       	adc	r31, r31
    7404:	e8 57       	subi	r30, 0x78	; 120
    7406:	ff 4f       	sbci	r31, 0xFF	; 255
    7408:	01 90       	ld	r0, Z+
    740a:	f0 81       	ld	r31, Z
    740c:	e0 2d       	mov	r30, r0
    740e:	60 83       	st	Z, r22
}
    7410:	08 95       	ret

00007412 <DIO_Read_PORT>:
/****************************************************************************/
UINT8_t DIO_Read_PORT(const DIO_PORT_ID_t PORT_ID){
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { PINA_ADD, PINB_ADD, PINC_ADD, PIND_ADD };
	return *Reg[PORT_ID];
    7412:	e8 2f       	mov	r30, r24
    7414:	f0 e0       	ldi	r31, 0x00	; 0
    7416:	ee 0f       	add	r30, r30
    7418:	ff 1f       	adc	r31, r31
    741a:	e0 58       	subi	r30, 0x80	; 128
    741c:	ff 4f       	sbci	r31, 0xFF	; 255
    741e:	01 90       	ld	r0, Z+
    7420:	f0 81       	ld	r31, Z
    7422:	e0 2d       	mov	r30, r0
    7424:	80 81       	ld	r24, Z
}
    7426:	08 95       	ret

00007428 <boot_program_page>:
#include "util/delay.h"
#include "FLASHER.h"

void
boot_program_page (UINT32_t page, UINT8_t *buf)
{
    7428:	ff 92       	push	r15
    742a:	0f 93       	push	r16
    742c:	1f 93       	push	r17
    742e:	cf 93       	push	r28
    7430:	df 93       	push	r29
    7432:	8b 01       	movw	r16, r22
    7434:	9c 01       	movw	r18, r24
    7436:	da 01       	movw	r26, r20
	UINT8_t sreg;
	UINT32_t address;
	UINT16_t word ;

	// Disable interrupts.
	GIC;
    7438:	8f b7       	in	r24, 0x3f	; 63
    743a:	8f 77       	andi	r24, 0x7F	; 127
    743c:	8f bf       	out	0x3f, r24	; 63
	sreg = SREG;
    743e:	ff b6       	in	r15, 0x3f	; 63
	address = page * PAGE_SIZE ;


	boot_page_erase_safe (address);
    7440:	07 b6       	in	r0, 0x37	; 55
    7442:	00 fc       	sbrc	r0, 0
    7444:	fd cf       	rjmp	.-6      	; 0x7440 <boot_program_page+0x18>
    7446:	e1 99       	sbic	0x1c, 1	; 28
    7448:	fe cf       	rjmp	.-4      	; 0x7446 <boot_program_page+0x1e>
    744a:	87 e0       	ldi	r24, 0x07	; 7
    744c:	00 0f       	add	r16, r16
    744e:	11 1f       	adc	r17, r17
    7450:	22 1f       	adc	r18, r18
    7452:	33 1f       	adc	r19, r19
    7454:	8a 95       	dec	r24
    7456:	d1 f7       	brne	.-12     	; 0x744c <boot_program_page+0x24>
    7458:	a8 01       	movw	r20, r16
    745a:	83 e0       	ldi	r24, 0x03	; 3
    745c:	f8 01       	movw	r30, r16
    745e:	80 93 57 00 	sts	0x0057, r24
    7462:	e8 95       	spm
    7464:	f8 01       	movw	r30, r16
	{
		// Set up little Endian word.
		word  = *buf++;
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
    7466:	11 e0       	ldi	r17, 0x01	; 1
	address = page * PAGE_SIZE ;


	boot_page_erase_safe (address);

	for (i=0; i<PAGE_SIZE; i+=2)
    7468:	ba 01       	movw	r22, r20
    746a:	60 58       	subi	r22, 0x80	; 128
    746c:	7f 4f       	sbci	r23, 0xFF	; 255
	{
		// Set up little Endian word.
		word  = *buf++;
    746e:	9c 91       	ld	r25, X
		word += (*buf++) << 8;
    7470:	11 96       	adiw	r26, 0x01	; 1
    7472:	8c 91       	ld	r24, X
    7474:	11 97       	sbiw	r26, 0x01	; 1
#include "util/delay.h"
#include "FLASHER.h"

void
boot_program_page (UINT32_t page, UINT8_t *buf)
{
    7476:	12 96       	adiw	r26, 0x02	; 2
	{
		// Set up little Endian word.
		word  = *buf++;
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
    7478:	07 b6       	in	r0, 0x37	; 55
    747a:	00 fc       	sbrc	r0, 0
    747c:	fd cf       	rjmp	.-6      	; 0x7478 <boot_program_page+0x50>
    747e:	e1 99       	sbic	0x1c, 1	; 28
    7480:	fe cf       	rjmp	.-4      	; 0x747e <boot_program_page+0x56>
    7482:	38 2f       	mov	r19, r24
    7484:	20 e0       	ldi	r18, 0x00	; 0
    7486:	e9 01       	movw	r28, r18
    7488:	c9 0f       	add	r28, r25
    748a:	d1 1d       	adc	r29, r1
    748c:	0e 01       	movw	r0, r28
    748e:	10 93 57 00 	sts	0x0057, r17
    7492:	e8 95       	spm
    7494:	11 24       	eor	r1, r1
    7496:	32 96       	adiw	r30, 0x02	; 2
	address = page * PAGE_SIZE ;


	boot_page_erase_safe (address);

	for (i=0; i<PAGE_SIZE; i+=2)
    7498:	e6 17       	cp	r30, r22
    749a:	f7 07       	cpc	r31, r23
    749c:	41 f7       	brne	.-48     	; 0x746e <boot_program_page+0x46>
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
	}

	boot_page_write_safe (address);     // Store buffer in flash page.
    749e:	07 b6       	in	r0, 0x37	; 55
    74a0:	00 fc       	sbrc	r0, 0
    74a2:	fd cf       	rjmp	.-6      	; 0x749e <boot_program_page+0x76>
    74a4:	e1 99       	sbic	0x1c, 1	; 28
    74a6:	fe cf       	rjmp	.-4      	; 0x74a4 <boot_program_page+0x7c>
    74a8:	85 e0       	ldi	r24, 0x05	; 5
    74aa:	fa 01       	movw	r30, r20
    74ac:	80 93 57 00 	sts	0x0057, r24
    74b0:	e8 95       	spm

	// Reenable RWW-section again. We need this if we want to jump back
	// to the application after bootloading.

	boot_rww_enable_safe();
    74b2:	07 b6       	in	r0, 0x37	; 55
    74b4:	00 fc       	sbrc	r0, 0
    74b6:	fd cf       	rjmp	.-6      	; 0x74b2 <boot_program_page+0x8a>
    74b8:	e1 99       	sbic	0x1c, 1	; 28
    74ba:	fe cf       	rjmp	.-4      	; 0x74b8 <boot_program_page+0x90>
    74bc:	81 e1       	ldi	r24, 0x11	; 17
    74be:	80 93 57 00 	sts	0x0057, r24
    74c2:	e8 95       	spm

	// Re-enable interrupts (if they were ever enabled).

	SREG = sreg;
    74c4:	ff be       	out	0x3f, r15	; 63
	GIE;
    74c6:	8f b7       	in	r24, 0x3f	; 63
    74c8:	80 68       	ori	r24, 0x80	; 128
    74ca:	8f bf       	out	0x3f, r24	; 63
}
    74cc:	df 91       	pop	r29
    74ce:	cf 91       	pop	r28
    74d0:	1f 91       	pop	r17
    74d2:	0f 91       	pop	r16
    74d4:	ff 90       	pop	r15
    74d6:	08 95       	ret

000074d8 <FLASH_Data_Write>:
#include "FLASH_DATA.h"
void
FLASH_Data_Write(UINT16_t Address, UINT8_t Data)
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEMWE))
    74d8:	e2 99       	sbic	0x1c, 2	; 28
    74da:	fe cf       	rjmp	.-4      	; 0x74d8 <FLASH_Data_Write>
	;
	/* Set up address and data registers */
	EEAR = Address;
    74dc:	9f bb       	out	0x1f, r25	; 31
    74de:	8e bb       	out	0x1e, r24	; 30
	EEDR = Data;
    74e0:	6d bb       	out	0x1d, r22	; 29
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
    74e2:	e2 9a       	sbi	0x1c, 2	; 28
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
    74e4:	e1 9a       	sbi	0x1c, 1	; 28
}
    74e6:	08 95       	ret

000074e8 <FLASH_Data_Read>:
UINT8_t
FLASH_Data_Read(UINT16_t Address)
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEMWE))
    74e8:	e2 99       	sbic	0x1c, 2	; 28
    74ea:	fe cf       	rjmp	.-4      	; 0x74e8 <FLASH_Data_Read>
	;
	/* Set up address register */
	EEAR = Address;
    74ec:	9f bb       	out	0x1f, r25	; 31
    74ee:	8e bb       	out	0x1e, r24	; 30
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    74f0:	e0 9a       	sbi	0x1c, 0	; 28
	/* Return data from data register */
	return EEDR;
    74f2:	8d b3       	in	r24, 0x1d	; 29
}
    74f4:	08 95       	ret

000074f6 <Display_Page>:

	return AppIsFlashed;
}

void
Display_Page(UINT8_t*Data){
    74f6:	1f 93       	push	r17
    74f8:	cf 93       	push	r28
    74fa:	df 93       	push	r29
    74fc:	ec 01       	movw	r28, r24
    74fe:	10 e0       	ldi	r17, 0x00	; 0
	UINT8_t i;
	for (i = 0; i < PAGE_SIZE; ++i) {
		URT_Tx_Char(Data[i]);
    7500:	fe 01       	movw	r30, r28
    7502:	e1 0f       	add	r30, r17
    7504:	f1 1d       	adc	r31, r1
    7506:	80 81       	ld	r24, Z
    7508:	0e 94 7f 3b 	call	0x76fe	; 0x76fe <URT_Tx_Char>
}

void
Display_Page(UINT8_t*Data){
	UINT8_t i;
	for (i = 0; i < PAGE_SIZE; ++i) {
    750c:	1f 5f       	subi	r17, 0xFF	; 255
    750e:	10 38       	cpi	r17, 0x80	; 128
    7510:	b9 f7       	brne	.-18     	; 0x7500 <Display_Page+0xa>
		URT_Tx_Char(Data[i]);
	}
}
    7512:	df 91       	pop	r29
    7514:	cf 91       	pop	r28
    7516:	1f 91       	pop	r17
    7518:	08 95       	ret

0000751a <PARSER_Record>:
void
Display_Page(UINT8_t*Data);

BOOL_t
PARSER_Record(UINT8_t*Data, UINT8_t*Record)
{
    751a:	af 92       	push	r10
    751c:	bf 92       	push	r11
    751e:	df 92       	push	r13
    7520:	ef 92       	push	r14
    7522:	ff 92       	push	r15
    7524:	0f 93       	push	r16
    7526:	df 93       	push	r29
    7528:	cf 93       	push	r28
    752a:	00 d0       	rcall	.+0      	; 0x752c <PARSER_Record+0x12>
    752c:	cd b7       	in	r28, 0x3d	; 61
    752e:	de b7       	in	r29, 0x3e	; 62
    7530:	7c 01       	movw	r14, r24
    7532:	5b 01       	movw	r10, r22
	UINT8_t j = 0;
	BOOL_t AppIsFlashed = FALSE;
	/*check if there is received record*/

	/*check if record hex file ended*/
	if (0x01 == Asci2Hex(Record[6], Record[7])) {
    7534:	fb 01       	movw	r30, r22
    7536:	86 81       	ldd	r24, Z+6	; 0x06
    7538:	67 81       	ldd	r22, Z+7	; 0x07
    753a:	0e 94 ce 38 	call	0x719c	; 0x719c <Asci2Hex>
    753e:	81 30       	cpi	r24, 0x01	; 1
    7540:	21 f5       	brne	.+72     	; 0x758a <PARSER_Record+0x70>
		/*check if there is reminder record bytes */
		if (Idx_Data > 0) {
    7542:	80 91 2d 01 	lds	r24, 0x012D
    7546:	88 23       	and	r24, r24
    7548:	39 f4       	brne	.+14     	; 0x7558 <PARSER_Record+0x3e>
    754a:	1d c0       	rjmp	.+58     	; 0x7586 <PARSER_Record+0x6c>
			/*fill reminder bytes with oxff value*/
			while (Idx_Data < PAGE_SIZE) {
				Data[Idx_Data] = 0xff;
    754c:	f7 01       	movw	r30, r14
    754e:	e8 0f       	add	r30, r24
    7550:	f1 1d       	adc	r31, r1
    7552:	90 83       	st	Z, r25
    7554:	8f 5f       	subi	r24, 0xFF	; 255
    7556:	01 c0       	rjmp	.+2      	; 0x755a <PARSER_Record+0x40>
    7558:	9f ef       	ldi	r25, 0xFF	; 255
	/*check if record hex file ended*/
	if (0x01 == Asci2Hex(Record[6], Record[7])) {
		/*check if there is reminder record bytes */
		if (Idx_Data > 0) {
			/*fill reminder bytes with oxff value*/
			while (Idx_Data < PAGE_SIZE) {
    755a:	87 ff       	sbrs	r24, 7
    755c:	f7 cf       	rjmp	.-18     	; 0x754c <PARSER_Record+0x32>
    755e:	80 93 2d 01 	sts	0x012D, r24
			Display_Page(Data);
#endif


			/*Flash code*/
			boot_program_page(NO_Pages, Data);
    7562:	60 91 2b 01 	lds	r22, 0x012B
    7566:	70 91 2c 01 	lds	r23, 0x012C
    756a:	80 e0       	ldi	r24, 0x00	; 0
    756c:	90 e0       	ldi	r25, 0x00	; 0
    756e:	a7 01       	movw	r20, r14
    7570:	0e 94 14 3a 	call	0x7428	; 0x7428 <boot_program_page>

			++NO_Pages;
    7574:	80 91 2b 01 	lds	r24, 0x012B
    7578:	90 91 2c 01 	lds	r25, 0x012C
    757c:	01 96       	adiw	r24, 0x01	; 1
    757e:	90 93 2c 01 	sts	0x012C, r25
    7582:	80 93 2b 01 	sts	0x012B, r24
    7586:	81 e0       	ldi	r24, 0x01	; 1
    7588:	41 c0       	rjmp	.+130    	; 0x760c <PARSER_Record+0xf2>
		}
		AppIsFlashed = TRUE;
	} else if (0x00 == Asci2Hex(Record[6], Record[7])) {
    758a:	f5 01       	movw	r30, r10
    758c:	86 81       	ldd	r24, Z+6	; 0x06
    758e:	67 81       	ldd	r22, Z+7	; 0x07
    7590:	0e 94 ce 38 	call	0x719c	; 0x719c <Asci2Hex>
    7594:	88 23       	and	r24, r24
    7596:	c9 f5       	brne	.+114    	; 0x760a <PARSER_Record+0xf0>
		/*store current record size*/
		Record_Size = Asci2Hex(Record[0], Record[1]);
    7598:	f5 01       	movw	r30, r10
    759a:	80 81       	ld	r24, Z
    759c:	61 81       	ldd	r22, Z+1	; 0x01
    759e:	0e 94 ce 38 	call	0x719c	; 0x719c <Asci2Hex>
    75a2:	d8 2e       	mov	r13, r24
    75a4:	00 e0       	ldi	r16, 0x00	; 0
    75a6:	2d c0       	rjmp	.+90     	; 0x7602 <PARSER_Record+0xe8>
		/*extract data from the recorder*/
		for (Idx_Record = 0; Idx_Record < Record_Size; ++Idx_Record) {
			Data[Idx_Data] = Asci2Hex(Record[j + 8], Record[j + 9]);
    75a8:	80 91 2d 01 	lds	r24, 0x012D
    75ac:	97 01       	movw	r18, r14
    75ae:	28 0f       	add	r18, r24
    75b0:	31 1d       	adc	r19, r1
    75b2:	3a 83       	std	Y+2, r19	; 0x02
    75b4:	29 83       	std	Y+1, r18	; 0x01
    75b6:	f5 01       	movw	r30, r10
    75b8:	e9 0f       	add	r30, r25
    75ba:	f1 1d       	adc	r31, r1
    75bc:	80 85       	ldd	r24, Z+8	; 0x08
    75be:	61 85       	ldd	r22, Z+9	; 0x09
    75c0:	0e 94 ce 38 	call	0x719c	; 0x719c <Asci2Hex>
    75c4:	e9 81       	ldd	r30, Y+1	; 0x01
    75c6:	fa 81       	ldd	r31, Y+2	; 0x02
    75c8:	80 83       	st	Z, r24
			//	UDR=Data[Idx_Data];
			//	_delay_ms(1000);
			++Idx_Data;
    75ca:	80 91 2d 01 	lds	r24, 0x012D
    75ce:	8f 5f       	subi	r24, 0xFF	; 255
    75d0:	80 93 2d 01 	sts	0x012D, r24
			if (PAGE_SIZE == Idx_Data) {
    75d4:	80 38       	cpi	r24, 0x80	; 128
    75d6:	a1 f4       	brne	.+40     	; 0x7600 <PARSER_Record+0xe6>
#if 0
				Display_Page(Data);
#endif

				/*Flash code*/
				boot_program_page(NO_Pages, Data);
    75d8:	60 91 2b 01 	lds	r22, 0x012B
    75dc:	70 91 2c 01 	lds	r23, 0x012C
    75e0:	80 e0       	ldi	r24, 0x00	; 0
    75e2:	90 e0       	ldi	r25, 0x00	; 0
    75e4:	a7 01       	movw	r20, r14
    75e6:	0e 94 14 3a 	call	0x7428	; 0x7428 <boot_program_page>
				Idx_Data = 0;
    75ea:	10 92 2d 01 	sts	0x012D, r1
				++NO_Pages;
    75ee:	80 91 2b 01 	lds	r24, 0x012B
    75f2:	90 91 2c 01 	lds	r25, 0x012C
    75f6:	01 96       	adiw	r24, 0x01	; 1
    75f8:	90 93 2c 01 	sts	0x012C, r25
    75fc:	80 93 2b 01 	sts	0x012B, r24
		AppIsFlashed = TRUE;
	} else if (0x00 == Asci2Hex(Record[6], Record[7])) {
		/*store current record size*/
		Record_Size = Asci2Hex(Record[0], Record[1]);
		/*extract data from the recorder*/
		for (Idx_Record = 0; Idx_Record < Record_Size; ++Idx_Record) {
    7600:	0f 5f       	subi	r16, 0xFF	; 255
    7602:	90 2f       	mov	r25, r16
    7604:	99 0f       	add	r25, r25
    7606:	0d 15       	cp	r16, r13
    7608:	78 f2       	brcs	.-98     	; 0x75a8 <PARSER_Record+0x8e>
    760a:	80 e0       	ldi	r24, 0x00	; 0
			j += 2;
		}
	}

	return AppIsFlashed;
}
    760c:	0f 90       	pop	r0
    760e:	0f 90       	pop	r0
    7610:	cf 91       	pop	r28
    7612:	df 91       	pop	r29
    7614:	0f 91       	pop	r16
    7616:	ff 90       	pop	r15
    7618:	ef 90       	pop	r14
    761a:	df 90       	pop	r13
    761c:	bf 90       	pop	r11
    761e:	af 90       	pop	r10
    7620:	08 95       	ret

00007622 <RECORD_Get>:


static UINT8_t Record[MAX_RECORD_SIZE];

UINT8_t*
RECORD_Get(void){
    7622:	cf 93       	push	r28
    7624:	df 93       	push	r29
    7626:	c0 e0       	ldi	r28, 0x00	; 0
    7628:	d0 e0       	ldi	r29, 0x00	; 0
	UINT8_t Character;
	UINT16_t i=0;

	do {
		Character = URT_Rx_Char();
    762a:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <URT_Rx_Char>
		if (Character != ':') {
    762e:	8a 33       	cpi	r24, 0x3A	; 58
    7630:	e1 f3       	breq	.-8      	; 0x762a <RECORD_Get+0x8>
			Record[i] = Character;
    7632:	fe 01       	movw	r30, r28
    7634:	e2 5d       	subi	r30, 0xD2	; 210
    7636:	fe 4f       	sbci	r31, 0xFE	; 254
    7638:	80 83       	st	Z, r24
			++i;
		}

	} while (Character != STOP_CHAR);
    763a:	8e 32       	cpi	r24, 0x2E	; 46
    763c:	11 f0       	breq	.+4      	; 0x7642 <RECORD_Get+0x20>

	do {
		Character = URT_Rx_Char();
		if (Character != ':') {
			Record[i] = Character;
			++i;
    763e:	21 96       	adiw	r28, 0x01	; 1
    7640:	f4 cf       	rjmp	.-24     	; 0x762a <RECORD_Get+0x8>
		}

	} while (Character != STOP_CHAR);

	return &Record[0];
}
    7642:	8e e2       	ldi	r24, 0x2E	; 46
    7644:	91 e0       	ldi	r25, 0x01	; 1
    7646:	df 91       	pop	r29
    7648:	cf 91       	pop	r28
    764a:	08 95       	ret

0000764c <UDS_Send_Negative_Response>:
	URT_Tx_Char(UDS_POSITIVE_RESPONSE);
}

void
UDS_Send_Negative_Response(void){
	URT_Tx_Char(UDS_NEGATIVE_RESPONSE);
    764c:	8d e2       	ldi	r24, 0x2D	; 45
    764e:	0e 94 7f 3b 	call	0x76fe	; 0x76fe <URT_Tx_Char>
}
    7652:	08 95       	ret

00007654 <UDS_Send_Positive_Response>:
	return Request;
}

void
UDS_Send_Positive_Response(void){
	URT_Tx_Char(UDS_POSITIVE_RESPONSE);
    7654:	8b e2       	ldi	r24, 0x2B	; 43
    7656:	0e 94 7f 3b 	call	0x76fe	; 0x76fe <URT_Tx_Char>
}
    765a:	08 95       	ret

0000765c <UDS_Read_Request>:

	UDS_t Request = UDS_NO_REQ;

	UINT8_t Reading;

	Reading = FLASH_Data_Read(UDS_REQ_ADDRESS);
    765c:	81 e0       	ldi	r24, 0x01	; 1
    765e:	90 e0       	ldi	r25, 0x00	; 0
    7660:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <FLASH_Data_Read>
    7664:	20 e1       	ldi	r18, 0x10	; 16
    7666:	37 e2       	ldi	r19, 0x27	; 39
    7668:	48 ec       	ldi	r20, 0xC8	; 200
    766a:	50 e0       	ldi	r21, 0x00	; 0
    766c:	fa 01       	movw	r30, r20
    766e:	31 97       	sbiw	r30, 0x01	; 1
    7670:	f1 f7       	brne	.-4      	; 0x766e <UDS_Read_Request+0x12>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7672:	21 50       	subi	r18, 0x01	; 1
    7674:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7676:	d1 f7       	brne	.-12     	; 0x766c <UDS_Read_Request+0x10>

	_delay_ms(1000);

	switch (Reading) {
    7678:	80 33       	cpi	r24, 0x30	; 48
    767a:	11 f4       	brne	.+4      	; 0x7680 <UDS_Read_Request+0x24>
    767c:	80 e3       	ldi	r24, 0x30	; 48
    767e:	08 95       	ret
    7680:	88 ef       	ldi	r24, 0xF8	; 248
	default:

		break;
	}
	return Request;
}
    7682:	08 95       	ret

00007684 <UDS_Write_Request>:
#define UDS_REQ_ADDRESS 0x01

void
UDS_Write_Request(UDS_t Request){

	switch(Request){
    7684:	80 33       	cpi	r24, 0x30	; 48
    7686:	31 f0       	breq	.+12     	; 0x7694 <UDS_Write_Request+0x10>
    7688:	88 3f       	cpi	r24, 0xF8	; 248
    768a:	49 f4       	brne	.+18     	; 0x769e <UDS_Write_Request+0x1a>

	case UDS_NO_REQ:
		FLASH_Data_Write(UDS_REQ_ADDRESS, UDS_NO_REQ);
    768c:	81 e0       	ldi	r24, 0x01	; 1
    768e:	90 e0       	ldi	r25, 0x00	; 0
    7690:	68 ef       	ldi	r22, 0xF8	; 248
    7692:	03 c0       	rjmp	.+6      	; 0x769a <UDS_Write_Request+0x16>
		break;

	case UDS_REQ_DATA_TRANSFER:
		FLASH_Data_Write(UDS_REQ_ADDRESS, UDS_REQ_DATA_TRANSFER);
    7694:	81 e0       	ldi	r24, 0x01	; 1
    7696:	90 e0       	ldi	r25, 0x00	; 0
    7698:	60 e3       	ldi	r22, 0x30	; 48
    769a:	0e 94 6c 3a 	call	0x74d8	; 0x74d8 <FLASH_Data_Write>
    769e:	80 e1       	ldi	r24, 0x10	; 16
    76a0:	97 e2       	ldi	r25, 0x27	; 39
    76a2:	28 ec       	ldi	r18, 0xC8	; 200
    76a4:	30 e0       	ldi	r19, 0x00	; 0
    76a6:	f9 01       	movw	r30, r18
    76a8:	31 97       	sbiw	r30, 0x01	; 1
    76aa:	f1 f7       	brne	.-4      	; 0x76a8 <UDS_Write_Request+0x24>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    76ac:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    76ae:	d9 f7       	brne	.-10     	; 0x76a6 <UDS_Write_Request+0x22>

	}

	_delay_ms(1000);

}
    76b0:	08 95       	ret

000076b2 <URT_Rx>:
#include "STD_MEMORY_MAP.h"
#include "STD_BITS.h"
#include "URT.h"

void URT_Rx(const URT_MODE_t MODE){
	switch (MODE) {
    76b2:	88 23       	and	r24, r24
    76b4:	19 f0       	breq	.+6      	; 0x76bc <URT_Rx+0xa>
    76b6:	81 30       	cpi	r24, 0x01	; 1
    76b8:	21 f4       	brne	.+8      	; 0x76c2 <URT_Rx+0x10>
    76ba:	02 c0       	rjmp	.+4      	; 0x76c0 <URT_Rx+0xe>
	case URT_ENABLE:
		SET_BIT(UCSRB, 4);
    76bc:	54 9a       	sbi	0x0a, 4	; 10
    76be:	08 95       	ret
		break;
	case URT_DISABLE:
		CLEAR_BIT(UCSRB, 4);
    76c0:	54 98       	cbi	0x0a, 4	; 10
    76c2:	08 95       	ret

000076c4 <URT_Tx>:
		break;
	}
}
void URT_Tx(const URT_MODE_t MODE){
	switch (MODE) {
    76c4:	88 23       	and	r24, r24
    76c6:	19 f0       	breq	.+6      	; 0x76ce <URT_Tx+0xa>
    76c8:	81 30       	cpi	r24, 0x01	; 1
    76ca:	21 f4       	brne	.+8      	; 0x76d4 <URT_Tx+0x10>
    76cc:	02 c0       	rjmp	.+4      	; 0x76d2 <URT_Tx+0xe>
	case URT_ENABLE:
		SET_BIT(UCSRB, 3);
    76ce:	53 9a       	sbi	0x0a, 3	; 10
    76d0:	08 95       	ret
		break;
	case URT_DISABLE:
		CLEAR_BIT(UCSRB, 3);
    76d2:	53 98       	cbi	0x0a, 3	; 10
    76d4:	08 95       	ret

000076d6 <URT_Init>:
		break;
	}
}
void URT_Init(void){
	SET_BIT(UCSRC, 1);
    76d6:	80 b5       	in	r24, 0x20	; 32
    76d8:	82 60       	ori	r24, 0x02	; 2
    76da:	80 bd       	out	0x20, r24	; 32
	SET_BIT(UCSRC, 2);
    76dc:	80 b5       	in	r24, 0x20	; 32
    76de:	84 60       	ori	r24, 0x04	; 4
    76e0:	80 bd       	out	0x20, r24	; 32
	UBRRH = URT_BAUD_RATE >> 8;
    76e2:	10 bc       	out	0x20, r1	; 32
	UBRRL = URT_BAUD_RATE;
    76e4:	83 e3       	ldi	r24, 0x33	; 51
    76e6:	89 b9       	out	0x09, r24	; 9

	/*enable full duplex mode*/
	URT_Tx(URT_ENABLE);
    76e8:	80 e0       	ldi	r24, 0x00	; 0
    76ea:	0e 94 62 3b 	call	0x76c4	; 0x76c4 <URT_Tx>
	URT_Rx(URT_ENABLE);
    76ee:	80 e0       	ldi	r24, 0x00	; 0
    76f0:	0e 94 59 3b 	call	0x76b2	; 0x76b2 <URT_Rx>
}
    76f4:	08 95       	ret

000076f6 <URT_Rx_Char>:

UINT8_t URT_Rx_Char(void){
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<7)) )
    76f6:	5f 9b       	sbis	0x0b, 7	; 11
    76f8:	fe cf       	rjmp	.-4      	; 0x76f6 <URT_Rx_Char>
	;
	/* Get and return received data from buffer */
	return UDR;
    76fa:	8c b1       	in	r24, 0x0c	; 12
}
    76fc:	08 95       	ret

000076fe <URT_Tx_Char>:
void URT_Tx_Char(const UINT8_t CHAR){
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<5)) )
    76fe:	5d 9b       	sbis	0x0b, 5	; 11
    7700:	fe cf       	rjmp	.-4      	; 0x76fe <URT_Tx_Char>
	;
	/* Put data into buffer, sends the data */
	UDR = CHAR;
    7702:	8c b9       	out	0x0c, r24	; 12
}
    7704:	08 95       	ret

00007706 <BootLoader_Indicator>:
	}
	return 0;
}

void
BootLoader_Indicator(void){
    7706:	0f 93       	push	r16
    7708:	1f 93       	push	r17
    770a:	cf 93       	push	r28
    770c:	df 93       	push	r29

	UINT8_t i;
	DIO_WRITE_PIN_VALUE(DIO_PINC1, DIO_PIN_STATE_LOW);
    770e:	81 e1       	ldi	r24, 0x11	; 17
    7710:	60 e0       	ldi	r22, 0x00	; 0
    7712:	0e 94 44 39 	call	0x7288	; 0x7288 <DIO_WRITE_PIN_VALUE>
	DIO_WRITE_PIN_VALUE(DIO_PINC0, DIO_PIN_STATE_LOW);
    7716:	80 e1       	ldi	r24, 0x10	; 16
    7718:	60 e0       	ldi	r22, 0x00	; 0
    771a:	0e 94 44 39 	call	0x7288	; 0x7288 <DIO_WRITE_PIN_VALUE>
    771e:	10 e0       	ldi	r17, 0x00	; 0
	for(i=0; i<5; ++i){

		DIO_WRITE_PIN_VALUE(DIO_PINC0, 1^DIO_READ_PIN_VALUE(DIO_PINC0));
    7720:	01 e0       	ldi	r16, 0x01	; 1
    7722:	c8 ec       	ldi	r28, 0xC8	; 200
    7724:	d0 e0       	ldi	r29, 0x00	; 0
    7726:	80 e1       	ldi	r24, 0x10	; 16
    7728:	0e 94 e7 39 	call	0x73ce	; 0x73ce <DIO_READ_PIN_VALUE>
    772c:	68 2f       	mov	r22, r24
    772e:	60 27       	eor	r22, r16
    7730:	80 e1       	ldi	r24, 0x10	; 16
    7732:	0e 94 44 39 	call	0x7288	; 0x7288 <DIO_WRITE_PIN_VALUE>
    7736:	80 e1       	ldi	r24, 0x10	; 16
    7738:	97 e2       	ldi	r25, 0x27	; 39
    773a:	fe 01       	movw	r30, r28
    773c:	31 97       	sbiw	r30, 0x01	; 1
    773e:	f1 f7       	brne	.-4      	; 0x773c <BootLoader_Indicator+0x36>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7740:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7742:	d9 f7       	brne	.-10     	; 0x773a <BootLoader_Indicator+0x34>
BootLoader_Indicator(void){

	UINT8_t i;
	DIO_WRITE_PIN_VALUE(DIO_PINC1, DIO_PIN_STATE_LOW);
	DIO_WRITE_PIN_VALUE(DIO_PINC0, DIO_PIN_STATE_LOW);
	for(i=0; i<5; ++i){
    7744:	1f 5f       	subi	r17, 0xFF	; 255
    7746:	15 30       	cpi	r17, 0x05	; 5
    7748:	71 f7       	brne	.-36     	; 0x7726 <BootLoader_Indicator+0x20>
		DIO_WRITE_PIN_VALUE(DIO_PINC0, 1^DIO_READ_PIN_VALUE(DIO_PINC0));
		_delay_ms(1000);

	}

	DIO_WRITE_PIN_VALUE(DIO_PINC0, DIO_PIN_STATE_HIGH);
    774a:	80 e1       	ldi	r24, 0x10	; 16
    774c:	61 e0       	ldi	r22, 0x01	; 1
    774e:	0e 94 44 39 	call	0x7288	; 0x7288 <DIO_WRITE_PIN_VALUE>

}
    7752:	df 91       	pop	r29
    7754:	cf 91       	pop	r28
    7756:	1f 91       	pop	r17
    7758:	0f 91       	pop	r16
    775a:	08 95       	ret

0000775c <main>:
void
BootLoader_Indicator(void);


int
main(void){
    775c:	ef 92       	push	r14
    775e:	ff 92       	push	r15
    7760:	0f 93       	push	r16
    7762:	1f 93       	push	r17

	GIC;
    7764:	8f b7       	in	r24, 0x3f	; 63
    7766:	8f 77       	andi	r24, 0x7F	; 127
    7768:	8f bf       	out	0x3f, r24	; 63
	DIO_INIT();
    776a:	0e 94 76 39 	call	0x72ec	; 0x72ec <DIO_INIT>
	URT_Init();
    776e:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <URT_Init>
	BootLoader_Indicator();
    7772:	0e 94 83 3b 	call	0x7706	; 0x7706 <BootLoader_Indicator>

		case REQUEST_DATA_TRANSFER:

			if(TRUE==APP_Rx()){

				Bootloader_State=JMP_TO_APPLICATION_SECTION;
    7776:	04 e0       	ldi	r16, 0x04	; 4
		case CHECKING_APPLICATION_EXIST:

			if(APP_EXIST==APP_Read_State()){
				Bootloader_State=CHECKING_REQUEST_EXIST;
			}else {
				Bootloader_State=CHECKING_TYPE_OF_REQUEST;
    7778:	12 e0       	ldi	r17, 0x02	; 2
		switch(Bootloader_State){

		case CHECKING_APPLICATION_EXIST:

			if(APP_EXIST==APP_Read_State()){
				Bootloader_State=CHECKING_REQUEST_EXIST;
    777a:	ee 24       	eor	r14, r14
    777c:	e3 94       	inc	r14

			break;
		case CHECKING_TYPE_OF_REQUEST:

			if (UDS_REQ_DATA_TRANSFER==UDS_Read_Request()) {
				Bootloader_State = REQUEST_DATA_TRANSFER;
    777e:	83 e0       	ldi	r24, 0x03	; 3
    7780:	f8 2e       	mov	r15, r24
	URT_Init();
	BootLoader_Indicator();

	while(1){

		switch(Bootloader_State){
    7782:	80 91 34 02 	lds	r24, 0x0234
    7786:	82 30       	cpi	r24, 0x02	; 2
    7788:	d1 f0       	breq	.+52     	; 0x77be <main+0x62>
    778a:	83 30       	cpi	r24, 0x03	; 3
    778c:	28 f4       	brcc	.+10     	; 0x7798 <main+0x3c>
    778e:	88 23       	and	r24, r24
    7790:	41 f0       	breq	.+16     	; 0x77a2 <main+0x46>
    7792:	81 30       	cpi	r24, 0x01	; 1
    7794:	c1 f7       	brne	.-16     	; 0x7786 <main+0x2a>
    7796:	0c c0       	rjmp	.+24     	; 0x77b0 <main+0x54>
    7798:	83 30       	cpi	r24, 0x03	; 3
    779a:	d1 f0       	breq	.+52     	; 0x77d0 <main+0x74>
    779c:	84 30       	cpi	r24, 0x04	; 4
    779e:	99 f7       	brne	.-26     	; 0x7786 <main+0x2a>
    77a0:	1e c0       	rjmp	.+60     	; 0x77de <main+0x82>

		case CHECKING_APPLICATION_EXIST:

			if(APP_EXIST==APP_Read_State()){
    77a2:	0e 94 a2 38 	call	0x7144	; 0x7144 <APP_Read_State>
    77a6:	80 39       	cpi	r24, 0x90	; 144
    77a8:	39 f4       	brne	.+14     	; 0x77b8 <main+0x5c>
				Bootloader_State=CHECKING_REQUEST_EXIST;
    77aa:	e0 92 34 02 	sts	0x0234, r14
    77ae:	e9 cf       	rjmp	.-46     	; 0x7782 <main+0x26>
			}

			break;
		case CHECKING_REQUEST_EXIST:

			if(UDS_Read_Request()!=UDS_NO_REQ){
    77b0:	0e 94 2e 3b 	call	0x765c	; 0x765c <UDS_Read_Request>
    77b4:	88 3f       	cpi	r24, 0xF8	; 248
    77b6:	81 f0       	breq	.+32     	; 0x77d8 <main+0x7c>
				Bootloader_State=CHECKING_TYPE_OF_REQUEST;
    77b8:	10 93 34 02 	sts	0x0234, r17
    77bc:	e2 cf       	rjmp	.-60     	; 0x7782 <main+0x26>
			}

			break;
		case CHECKING_TYPE_OF_REQUEST:

			if (UDS_REQ_DATA_TRANSFER==UDS_Read_Request()) {
    77be:	0e 94 2e 3b 	call	0x765c	; 0x765c <UDS_Read_Request>
    77c2:	80 33       	cpi	r24, 0x30	; 48
    77c4:	f1 f6       	brne	.-68     	; 0x7782 <main+0x26>
				Bootloader_State = REQUEST_DATA_TRANSFER;
    77c6:	f0 92 34 02 	sts	0x0234, r15
				UDS_Send_Positive_Response();
    77ca:	0e 94 2a 3b 	call	0x7654	; 0x7654 <UDS_Send_Positive_Response>
    77ce:	d9 cf       	rjmp	.-78     	; 0x7782 <main+0x26>
			}
			break;

		case REQUEST_DATA_TRANSFER:

			if(TRUE==APP_Rx()){
    77d0:	0e 94 68 38 	call	0x70d0	; 0x70d0 <APP_Rx>
    77d4:	81 30       	cpi	r24, 0x01	; 1
    77d6:	a9 f6       	brne	.-86     	; 0x7782 <main+0x26>

				Bootloader_State=JMP_TO_APPLICATION_SECTION;
    77d8:	00 93 34 02 	sts	0x0234, r16
    77dc:	d2 cf       	rjmp	.-92     	; 0x7782 <main+0x26>
			}
			break;

		case JMP_TO_APPLICATION_SECTION:

			APP_Write_State(APP_EXIST);
    77de:	80 e9       	ldi	r24, 0x90	; 144
    77e0:	0e 94 b6 38 	call	0x716c	; 0x716c <APP_Write_State>
			UDS_Write_Request(UDS_NO_REQ);
    77e4:	88 ef       	ldi	r24, 0xF8	; 248
    77e6:	0e 94 42 3b 	call	0x7684	; 0x7684 <UDS_Write_Request>
			BootLoader_Indicator();
    77ea:	0e 94 83 3b 	call	0x7706	; 0x7706 <BootLoader_Indicator>
			asm("jmp 0");
    77ee:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
    77f2:	c7 cf       	rjmp	.-114    	; 0x7782 <main+0x26>

000077f4 <_exit>:
    77f4:	f8 94       	cli

000077f6 <__stop_program>:
    77f6:	ff cf       	rjmp	.-2      	; 0x77f6 <__stop_program>
