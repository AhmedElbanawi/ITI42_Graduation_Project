
ElectricMeterBootLoaderVersion2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000cfa  00007000  00007000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  00007cfa  00000dae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000190  008000a8  008000a8  00000df6  2**0
                  ALLOC
  3 .eeprom       00000192  00810000  00810000  00000df6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .stab         000029e8  00000000  00000000  00000f88  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000174c  00000000  00000000  00003970  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000040  00000000  00000000  000050bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000040  00000000  00000000  000050fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000002fe  00000000  00000000  0000513c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000001dc  00000000  00000000  0000543a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000001ae  00000000  00000000  00005616  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000040  00000000  00000000  000057c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000000f5  00000000  00000000  00005804  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000001f0  00000000  00000000  000058f9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 2a 38 	jmp	0x7054	; 0x7054 <__ctors_end>
    7004:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7008:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    700c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7010:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7014:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7018:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    701c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7020:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7024:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7028:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    702c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7030:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7034:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7038:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    703c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7040:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7044:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7048:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    704c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7050:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>

00007054 <__ctors_end>:
    7054:	11 24       	eor	r1, r1
    7056:	1f be       	out	0x3f, r1	; 63
    7058:	cf e5       	ldi	r28, 0x5F	; 95
    705a:	d8 e0       	ldi	r29, 0x08	; 8
    705c:	de bf       	out	0x3e, r29	; 62
    705e:	cd bf       	out	0x3d, r28	; 61

00007060 <__do_copy_data>:
    7060:	10 e0       	ldi	r17, 0x00	; 0
    7062:	a0 e6       	ldi	r26, 0x60	; 96
    7064:	b0 e0       	ldi	r27, 0x00	; 0
    7066:	ea ef       	ldi	r30, 0xFA	; 250
    7068:	fc e7       	ldi	r31, 0x7C	; 124
    706a:	02 c0       	rjmp	.+4      	; 0x7070 <.do_copy_data_start>

0000706c <.do_copy_data_loop>:
    706c:	05 90       	lpm	r0, Z+
    706e:	0d 92       	st	X+, r0

00007070 <.do_copy_data_start>:
    7070:	a8 3a       	cpi	r26, 0xA8	; 168
    7072:	b1 07       	cpc	r27, r17
    7074:	d9 f7       	brne	.-10     	; 0x706c <.do_copy_data_loop>

00007076 <__do_clear_bss>:
    7076:	12 e0       	ldi	r17, 0x02	; 2
    7078:	a8 ea       	ldi	r26, 0xA8	; 168
    707a:	b0 e0       	ldi	r27, 0x00	; 0
    707c:	01 c0       	rjmp	.+2      	; 0x7080 <.do_clear_bss_start>

0000707e <.do_clear_bss_loop>:
    707e:	1d 92       	st	X+, r1

00007080 <.do_clear_bss_start>:
    7080:	a8 33       	cpi	r26, 0x38	; 56
    7082:	b1 07       	cpc	r27, r17
    7084:	e1 f7       	brne	.-8      	; 0x707e <.do_clear_bss_loop>
    7086:	0e 94 6f 3e 	call	0x7cde	; 0x7cde <main>
    708a:	0c 94 7b 3e 	jmp	0x7cf6	; 0x7cf6 <_exit>

0000708e <__bad_interrupt>:
    708e:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

00007092 <__lshrdi3>:
    7092:	ef 92       	push	r14
    7094:	ff 92       	push	r15
    7096:	0f 93       	push	r16
    7098:	df 93       	push	r29
    709a:	cf 93       	push	r28
    709c:	cd b7       	in	r28, 0x3d	; 61
    709e:	de b7       	in	r29, 0x3e	; 62
    70a0:	60 97       	sbiw	r28, 0x10	; 16
    70a2:	0f b6       	in	r0, 0x3f	; 63
    70a4:	f8 94       	cli
    70a6:	de bf       	out	0x3e, r29	; 62
    70a8:	0f be       	out	0x3f, r0	; 63
    70aa:	cd bf       	out	0x3d, r28	; 61
    70ac:	a8 2f       	mov	r26, r24
    70ae:	00 23       	and	r16, r16
    70b0:	09 f4       	brne	.+2      	; 0x70b4 <__lshrdi3+0x22>
    70b2:	61 c0       	rjmp	.+194    	; 0x7176 <__lshrdi3+0xe4>
    70b4:	7e 01       	movw	r14, r28
    70b6:	08 94       	sec
    70b8:	e1 1c       	adc	r14, r1
    70ba:	f1 1c       	adc	r15, r1
    70bc:	88 e0       	ldi	r24, 0x08	; 8
    70be:	f7 01       	movw	r30, r14
    70c0:	11 92       	st	Z+, r1
    70c2:	8a 95       	dec	r24
    70c4:	e9 f7       	brne	.-6      	; 0x70c0 <__lshrdi3+0x2e>
    70c6:	29 83       	std	Y+1, r18	; 0x01
    70c8:	3a 83       	std	Y+2, r19	; 0x02
    70ca:	4b 83       	std	Y+3, r20	; 0x03
    70cc:	5c 83       	std	Y+4, r21	; 0x04
    70ce:	6d 83       	std	Y+5, r22	; 0x05
    70d0:	7e 83       	std	Y+6, r23	; 0x06
    70d2:	af 83       	std	Y+7, r26	; 0x07
    70d4:	98 87       	std	Y+8, r25	; 0x08
    70d6:	80 e2       	ldi	r24, 0x20	; 32
    70d8:	80 1b       	sub	r24, r16
    70da:	e8 2f       	mov	r30, r24
    70dc:	ff 27       	eor	r31, r31
    70de:	e7 fd       	sbrc	r30, 7
    70e0:	f0 95       	com	r31
    70e2:	4d 81       	ldd	r20, Y+5	; 0x05
    70e4:	5e 81       	ldd	r21, Y+6	; 0x06
    70e6:	6f 81       	ldd	r22, Y+7	; 0x07
    70e8:	78 85       	ldd	r23, Y+8	; 0x08
    70ea:	18 16       	cp	r1, r24
    70ec:	84 f0       	brlt	.+32     	; 0x710e <__lshrdi3+0x7c>
    70ee:	1d 86       	std	Y+13, r1	; 0x0d
    70f0:	1e 86       	std	Y+14, r1	; 0x0e
    70f2:	1f 86       	std	Y+15, r1	; 0x0f
    70f4:	18 8a       	std	Y+16, r1	; 0x10
    70f6:	88 27       	eor	r24, r24
    70f8:	99 27       	eor	r25, r25
    70fa:	8e 1b       	sub	r24, r30
    70fc:	9f 0b       	sbc	r25, r31
    70fe:	04 c0       	rjmp	.+8      	; 0x7108 <__lshrdi3+0x76>
    7100:	76 95       	lsr	r23
    7102:	67 95       	ror	r22
    7104:	57 95       	ror	r21
    7106:	47 95       	ror	r20
    7108:	8a 95       	dec	r24
    710a:	d2 f7       	brpl	.-12     	; 0x7100 <__lshrdi3+0x6e>
    710c:	28 c0       	rjmp	.+80     	; 0x715e <__lshrdi3+0xcc>
    710e:	20 2f       	mov	r18, r16
    7110:	33 27       	eor	r19, r19
    7112:	27 fd       	sbrc	r18, 7
    7114:	30 95       	com	r19
    7116:	db 01       	movw	r26, r22
    7118:	ca 01       	movw	r24, r20
    711a:	02 2e       	mov	r0, r18
    711c:	04 c0       	rjmp	.+8      	; 0x7126 <__lshrdi3+0x94>
    711e:	b6 95       	lsr	r27
    7120:	a7 95       	ror	r26
    7122:	97 95       	ror	r25
    7124:	87 95       	ror	r24
    7126:	0a 94       	dec	r0
    7128:	d2 f7       	brpl	.-12     	; 0x711e <__lshrdi3+0x8c>
    712a:	8d 87       	std	Y+13, r24	; 0x0d
    712c:	9e 87       	std	Y+14, r25	; 0x0e
    712e:	af 87       	std	Y+15, r26	; 0x0f
    7130:	b8 8b       	std	Y+16, r27	; 0x10
    7132:	04 c0       	rjmp	.+8      	; 0x713c <__lshrdi3+0xaa>
    7134:	44 0f       	add	r20, r20
    7136:	55 1f       	adc	r21, r21
    7138:	66 1f       	adc	r22, r22
    713a:	77 1f       	adc	r23, r23
    713c:	ea 95       	dec	r30
    713e:	d2 f7       	brpl	.-12     	; 0x7134 <__lshrdi3+0xa2>
    7140:	89 81       	ldd	r24, Y+1	; 0x01
    7142:	9a 81       	ldd	r25, Y+2	; 0x02
    7144:	ab 81       	ldd	r26, Y+3	; 0x03
    7146:	bc 81       	ldd	r27, Y+4	; 0x04
    7148:	04 c0       	rjmp	.+8      	; 0x7152 <__lshrdi3+0xc0>
    714a:	b6 95       	lsr	r27
    714c:	a7 95       	ror	r26
    714e:	97 95       	ror	r25
    7150:	87 95       	ror	r24
    7152:	2a 95       	dec	r18
    7154:	d2 f7       	brpl	.-12     	; 0x714a <__lshrdi3+0xb8>
    7156:	48 2b       	or	r20, r24
    7158:	59 2b       	or	r21, r25
    715a:	6a 2b       	or	r22, r26
    715c:	7b 2b       	or	r23, r27
    715e:	49 87       	std	Y+9, r20	; 0x09
    7160:	5a 87       	std	Y+10, r21	; 0x0a
    7162:	6b 87       	std	Y+11, r22	; 0x0b
    7164:	7c 87       	std	Y+12, r23	; 0x0c
    7166:	29 85       	ldd	r18, Y+9	; 0x09
    7168:	3a 85       	ldd	r19, Y+10	; 0x0a
    716a:	4b 85       	ldd	r20, Y+11	; 0x0b
    716c:	5c 85       	ldd	r21, Y+12	; 0x0c
    716e:	6d 85       	ldd	r22, Y+13	; 0x0d
    7170:	7e 85       	ldd	r23, Y+14	; 0x0e
    7172:	af 85       	ldd	r26, Y+15	; 0x0f
    7174:	98 89       	ldd	r25, Y+16	; 0x10
    7176:	8a 2f       	mov	r24, r26
    7178:	60 96       	adiw	r28, 0x10	; 16
    717a:	0f b6       	in	r0, 0x3f	; 63
    717c:	f8 94       	cli
    717e:	de bf       	out	0x3e, r29	; 62
    7180:	0f be       	out	0x3f, r0	; 63
    7182:	cd bf       	out	0x3d, r28	; 61
    7184:	cf 91       	pop	r28
    7186:	df 91       	pop	r29
    7188:	0f 91       	pop	r16
    718a:	ff 90       	pop	r15
    718c:	ef 90       	pop	r14
    718e:	08 95       	ret

00007190 <__ashldi3>:
    7190:	ef 92       	push	r14
    7192:	ff 92       	push	r15
    7194:	0f 93       	push	r16
    7196:	df 93       	push	r29
    7198:	cf 93       	push	r28
    719a:	cd b7       	in	r28, 0x3d	; 61
    719c:	de b7       	in	r29, 0x3e	; 62
    719e:	60 97       	sbiw	r28, 0x10	; 16
    71a0:	0f b6       	in	r0, 0x3f	; 63
    71a2:	f8 94       	cli
    71a4:	de bf       	out	0x3e, r29	; 62
    71a6:	0f be       	out	0x3f, r0	; 63
    71a8:	cd bf       	out	0x3d, r28	; 61
    71aa:	a8 2f       	mov	r26, r24
    71ac:	00 23       	and	r16, r16
    71ae:	09 f4       	brne	.+2      	; 0x71b2 <__ashldi3+0x22>
    71b0:	61 c0       	rjmp	.+194    	; 0x7274 <__ashldi3+0xe4>
    71b2:	7e 01       	movw	r14, r28
    71b4:	08 94       	sec
    71b6:	e1 1c       	adc	r14, r1
    71b8:	f1 1c       	adc	r15, r1
    71ba:	88 e0       	ldi	r24, 0x08	; 8
    71bc:	f7 01       	movw	r30, r14
    71be:	11 92       	st	Z+, r1
    71c0:	8a 95       	dec	r24
    71c2:	e9 f7       	brne	.-6      	; 0x71be <__ashldi3+0x2e>
    71c4:	29 83       	std	Y+1, r18	; 0x01
    71c6:	3a 83       	std	Y+2, r19	; 0x02
    71c8:	4b 83       	std	Y+3, r20	; 0x03
    71ca:	5c 83       	std	Y+4, r21	; 0x04
    71cc:	6d 83       	std	Y+5, r22	; 0x05
    71ce:	7e 83       	std	Y+6, r23	; 0x06
    71d0:	af 83       	std	Y+7, r26	; 0x07
    71d2:	98 87       	std	Y+8, r25	; 0x08
    71d4:	80 e2       	ldi	r24, 0x20	; 32
    71d6:	80 1b       	sub	r24, r16
    71d8:	e8 2f       	mov	r30, r24
    71da:	ff 27       	eor	r31, r31
    71dc:	e7 fd       	sbrc	r30, 7
    71de:	f0 95       	com	r31
    71e0:	49 81       	ldd	r20, Y+1	; 0x01
    71e2:	5a 81       	ldd	r21, Y+2	; 0x02
    71e4:	6b 81       	ldd	r22, Y+3	; 0x03
    71e6:	7c 81       	ldd	r23, Y+4	; 0x04
    71e8:	18 16       	cp	r1, r24
    71ea:	84 f0       	brlt	.+32     	; 0x720c <__ashldi3+0x7c>
    71ec:	19 86       	std	Y+9, r1	; 0x09
    71ee:	1a 86       	std	Y+10, r1	; 0x0a
    71f0:	1b 86       	std	Y+11, r1	; 0x0b
    71f2:	1c 86       	std	Y+12, r1	; 0x0c
    71f4:	88 27       	eor	r24, r24
    71f6:	99 27       	eor	r25, r25
    71f8:	8e 1b       	sub	r24, r30
    71fa:	9f 0b       	sbc	r25, r31
    71fc:	04 c0       	rjmp	.+8      	; 0x7206 <__ashldi3+0x76>
    71fe:	44 0f       	add	r20, r20
    7200:	55 1f       	adc	r21, r21
    7202:	66 1f       	adc	r22, r22
    7204:	77 1f       	adc	r23, r23
    7206:	8a 95       	dec	r24
    7208:	d2 f7       	brpl	.-12     	; 0x71fe <__ashldi3+0x6e>
    720a:	28 c0       	rjmp	.+80     	; 0x725c <__ashldi3+0xcc>
    720c:	20 2f       	mov	r18, r16
    720e:	33 27       	eor	r19, r19
    7210:	27 fd       	sbrc	r18, 7
    7212:	30 95       	com	r19
    7214:	db 01       	movw	r26, r22
    7216:	ca 01       	movw	r24, r20
    7218:	02 2e       	mov	r0, r18
    721a:	04 c0       	rjmp	.+8      	; 0x7224 <__ashldi3+0x94>
    721c:	88 0f       	add	r24, r24
    721e:	99 1f       	adc	r25, r25
    7220:	aa 1f       	adc	r26, r26
    7222:	bb 1f       	adc	r27, r27
    7224:	0a 94       	dec	r0
    7226:	d2 f7       	brpl	.-12     	; 0x721c <__ashldi3+0x8c>
    7228:	89 87       	std	Y+9, r24	; 0x09
    722a:	9a 87       	std	Y+10, r25	; 0x0a
    722c:	ab 87       	std	Y+11, r26	; 0x0b
    722e:	bc 87       	std	Y+12, r27	; 0x0c
    7230:	04 c0       	rjmp	.+8      	; 0x723a <__ashldi3+0xaa>
    7232:	76 95       	lsr	r23
    7234:	67 95       	ror	r22
    7236:	57 95       	ror	r21
    7238:	47 95       	ror	r20
    723a:	ea 95       	dec	r30
    723c:	d2 f7       	brpl	.-12     	; 0x7232 <__ashldi3+0xa2>
    723e:	8d 81       	ldd	r24, Y+5	; 0x05
    7240:	9e 81       	ldd	r25, Y+6	; 0x06
    7242:	af 81       	ldd	r26, Y+7	; 0x07
    7244:	b8 85       	ldd	r27, Y+8	; 0x08
    7246:	04 c0       	rjmp	.+8      	; 0x7250 <__ashldi3+0xc0>
    7248:	88 0f       	add	r24, r24
    724a:	99 1f       	adc	r25, r25
    724c:	aa 1f       	adc	r26, r26
    724e:	bb 1f       	adc	r27, r27
    7250:	2a 95       	dec	r18
    7252:	d2 f7       	brpl	.-12     	; 0x7248 <__ashldi3+0xb8>
    7254:	48 2b       	or	r20, r24
    7256:	59 2b       	or	r21, r25
    7258:	6a 2b       	or	r22, r26
    725a:	7b 2b       	or	r23, r27
    725c:	4d 87       	std	Y+13, r20	; 0x0d
    725e:	5e 87       	std	Y+14, r21	; 0x0e
    7260:	6f 87       	std	Y+15, r22	; 0x0f
    7262:	78 8b       	std	Y+16, r23	; 0x10
    7264:	29 85       	ldd	r18, Y+9	; 0x09
    7266:	3a 85       	ldd	r19, Y+10	; 0x0a
    7268:	4b 85       	ldd	r20, Y+11	; 0x0b
    726a:	5c 85       	ldd	r21, Y+12	; 0x0c
    726c:	6d 85       	ldd	r22, Y+13	; 0x0d
    726e:	7e 85       	ldd	r23, Y+14	; 0x0e
    7270:	af 85       	ldd	r26, Y+15	; 0x0f
    7272:	98 89       	ldd	r25, Y+16	; 0x10
    7274:	8a 2f       	mov	r24, r26
    7276:	60 96       	adiw	r28, 0x10	; 16
    7278:	0f b6       	in	r0, 0x3f	; 63
    727a:	f8 94       	cli
    727c:	de bf       	out	0x3e, r29	; 62
    727e:	0f be       	out	0x3f, r0	; 63
    7280:	cd bf       	out	0x3d, r28	; 61
    7282:	cf 91       	pop	r28
    7284:	df 91       	pop	r29
    7286:	0f 91       	pop	r16
    7288:	ff 90       	pop	r15
    728a:	ef 90       	pop	r14
    728c:	08 95       	ret

0000728e <Display_Record>:
	return Finished;
}


void
Display_Record(void){
    728e:	1f 93       	push	r17
	UINT8_t i=0;

	if(Current_Record!=NULL_PTR){
    7290:	80 91 a8 00 	lds	r24, 0x00A8
    7294:	90 91 a9 00 	lds	r25, 0x00A9
    7298:	89 2b       	or	r24, r25
    729a:	b1 f0       	breq	.+44     	; 0x72c8 <Display_Record+0x3a>
    729c:	10 e0       	ldi	r17, 0x00	; 0

		do {
			URT_Tx_Char(Current_Record[i]);
    729e:	e0 91 a8 00 	lds	r30, 0x00A8
    72a2:	f0 91 a9 00 	lds	r31, 0x00A9
    72a6:	e1 0f       	add	r30, r17
    72a8:	f1 1d       	adc	r31, r1
    72aa:	80 81       	ld	r24, Z
    72ac:	0e 94 6b 3e 	call	0x7cd6	; 0x7cd6 <URT_Tx_Char>
			++i;
    72b0:	1f 5f       	subi	r17, 0xFF	; 255
		} while (Current_Record[i] != STOP_CHAR);
    72b2:	e0 91 a8 00 	lds	r30, 0x00A8
    72b6:	f0 91 a9 00 	lds	r31, 0x00A9
    72ba:	e1 0f       	add	r30, r17
    72bc:	f1 1d       	adc	r31, r1
    72be:	80 81       	ld	r24, Z
    72c0:	8e 32       	cpi	r24, 0x2E	; 46
    72c2:	69 f7       	brne	.-38     	; 0x729e <Display_Record+0x10>
		URT_Tx_Char(Current_Record[i]);
    72c4:	0e 94 6b 3e 	call	0x7cd6	; 0x7cd6 <URT_Tx_Char>
	}
}
    72c8:	1f 91       	pop	r17
    72ca:	08 95       	ret

000072cc <APP_Rx>:
BOOL_t
APP_Rx(void){

	BOOL_t Finished=FALSE;

	switch(App_State_Download){
    72cc:	80 91 aa 00 	lds	r24, 0x00AA
    72d0:	81 30       	cpi	r24, 0x01	; 1
    72d2:	79 f0       	breq	.+30     	; 0x72f2 <APP_Rx+0x26>
    72d4:	81 30       	cpi	r24, 0x01	; 1
    72d6:	28 f0       	brcs	.+10     	; 0x72e2 <APP_Rx+0x16>
    72d8:	82 30       	cpi	r24, 0x02	; 2
    72da:	d1 f0       	breq	.+52     	; 0x7310 <APP_Rx+0x44>
    72dc:	83 30       	cpi	r24, 0x03	; 3
    72de:	51 f5       	brne	.+84     	; 0x7334 <APP_Rx+0x68>
    72e0:	2b c0       	rjmp	.+86     	; 0x7338 <APP_Rx+0x6c>

	case RECEVING_RECORD:
		Current_Record=RECORD_Get();
    72e2:	0e 94 f4 3d 	call	0x7be8	; 0x7be8 <RECORD_Get>
    72e6:	90 93 a9 00 	sts	0x00A9, r25
    72ea:	80 93 a8 00 	sts	0x00A8, r24
		App_State_Download=CHECKING_RECORD_CRC;
    72ee:	81 e0       	ldi	r24, 0x01	; 1
    72f0:	1a c0       	rjmp	.+52     	; 0x7326 <APP_Rx+0x5a>
		//Display_Record();
		break;

	case CHECKING_RECORD_CRC:
		if(TRUE==CRC_Check(Current_Record)){
    72f2:	80 91 a8 00 	lds	r24, 0x00A8
    72f6:	90 91 a9 00 	lds	r25, 0x00A9
    72fa:	0e 94 eb 3b 	call	0x77d6	; 0x77d6 <CRC_Check>
    72fe:	81 30       	cpi	r24, 0x01	; 1
    7300:	11 f4       	brne	.+4      	; 0x7306 <APP_Rx+0x3a>
			App_State_Download=STORING_RECORD_WITH_PAGING;
    7302:	82 e0       	ldi	r24, 0x02	; 2
    7304:	10 c0       	rjmp	.+32     	; 0x7326 <APP_Rx+0x5a>
		}else {
			App_State_Download=RECEVING_RECORD;
    7306:	10 92 aa 00 	sts	0x00AA, r1
			UDS_Send_Negative_Response();
    730a:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <UDS_Send_Negative_Response>
    730e:	12 c0       	rjmp	.+36     	; 0x7334 <APP_Rx+0x68>
		}
			break;

	case STORING_RECORD_WITH_PAGING:
		if(TRUE==PARSER_Record(App, Current_Record)){
    7310:	60 91 a8 00 	lds	r22, 0x00A8
    7314:	70 91 a9 00 	lds	r23, 0x00A9
    7318:	8b ea       	ldi	r24, 0xAB	; 171
    731a:	90 e0       	ldi	r25, 0x00	; 0
    731c:	0e 94 70 3d 	call	0x7ae0	; 0x7ae0 <PARSER_Record>
    7320:	81 30       	cpi	r24, 0x01	; 1
    7322:	21 f4       	brne	.+8      	; 0x732c <APP_Rx+0x60>
			App_State_Download=APP_DOWNLOADING_ENDED;
    7324:	83 e0       	ldi	r24, 0x03	; 3
    7326:	80 93 aa 00 	sts	0x00AA, r24
    732a:	04 c0       	rjmp	.+8      	; 0x7334 <APP_Rx+0x68>
		}else {
			App_State_Download=RECEVING_RECORD;
    732c:	10 92 aa 00 	sts	0x00AA, r1
			UDS_Send_Positive_Response();
    7330:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <UDS_Send_Positive_Response>
    7334:	80 e0       	ldi	r24, 0x00	; 0
    7336:	08 95       	ret
		}
			break;

	case APP_DOWNLOADING_ENDED:
		Finished=TRUE;
		UDS_Send_Positive_Response();
    7338:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <UDS_Send_Positive_Response>
    733c:	81 e0       	ldi	r24, 0x01	; 1
			break;

	}
	return Finished;
}
    733e:	08 95       	ret

00007340 <APP_Read_State>:

	APP_STATE_t State = APP_NOT_EXIST;

	UINT8_t Reading;

	Reading = FLASH_Data_Read(APP_UPDATE_ADDRESS);
    7340:	80 e0       	ldi	r24, 0x00	; 0
    7342:	90 e0       	ldi	r25, 0x00	; 0
    7344:	0e 94 57 3d 	call	0x7aae	; 0x7aae <FLASH_Data_Read>
    7348:	20 e1       	ldi	r18, 0x10	; 16
    734a:	37 e2       	ldi	r19, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    734c:	48 ec       	ldi	r20, 0xC8	; 200
    734e:	50 e0       	ldi	r21, 0x00	; 0
    7350:	fa 01       	movw	r30, r20
    7352:	31 97       	sbiw	r30, 0x01	; 1
    7354:	f1 f7       	brne	.-4      	; 0x7352 <APP_Read_State+0x12>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7356:	21 50       	subi	r18, 0x01	; 1
    7358:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    735a:	d1 f7       	brne	.-12     	; 0x7350 <APP_Read_State+0x10>

	_delay_ms(1000);

	switch (Reading) {
    735c:	80 39       	cpi	r24, 0x90	; 144
    735e:	11 f4       	brne	.+4      	; 0x7364 <APP_Read_State+0x24>
    7360:	80 e9       	ldi	r24, 0x90	; 144
    7362:	08 95       	ret
    7364:	80 e7       	ldi	r24, 0x70	; 112
	default:

		break;
	}
	return State;
}
    7366:	08 95       	ret

00007368 <APP_Write_State>:
static UINT8_t App[PAGE_SIZE];

void
APP_Write_State(APP_STATE_t State){

	switch(State){
    7368:	80 37       	cpi	r24, 0x70	; 112
    736a:	19 f0       	breq	.+6      	; 0x7372 <APP_Write_State+0xa>
    736c:	80 39       	cpi	r24, 0x90	; 144
    736e:	51 f4       	brne	.+20     	; 0x7384 <APP_Write_State+0x1c>
    7370:	04 c0       	rjmp	.+8      	; 0x737a <APP_Write_State+0x12>

	case APP_NOT_EXIST:
		FLASH_Data_Write(APP_UPDATE_ADDRESS, APP_NOT_EXIST);
    7372:	80 e0       	ldi	r24, 0x00	; 0
    7374:	90 e0       	ldi	r25, 0x00	; 0
    7376:	60 e7       	ldi	r22, 0x70	; 112
    7378:	03 c0       	rjmp	.+6      	; 0x7380 <APP_Write_State+0x18>
		break;

	case APP_EXIST:
		FLASH_Data_Write(APP_UPDATE_ADDRESS, APP_EXIST);
    737a:	80 e0       	ldi	r24, 0x00	; 0
    737c:	90 e0       	ldi	r25, 0x00	; 0
    737e:	60 e9       	ldi	r22, 0x90	; 144
    7380:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <FLASH_Data_Write>
    7384:	80 e1       	ldi	r24, 0x10	; 16
    7386:	97 e2       	ldi	r25, 0x27	; 39
    7388:	28 ec       	ldi	r18, 0xC8	; 200
    738a:	30 e0       	ldi	r19, 0x00	; 0
    738c:	f9 01       	movw	r30, r18
    738e:	31 97       	sbiw	r30, 0x01	; 1
    7390:	f1 f7       	brne	.-4      	; 0x738e <APP_Write_State+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7392:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7394:	d9 f7       	brne	.-10     	; 0x738c <APP_Write_State+0x24>

	}

	_delay_ms(1000);

}
    7396:	08 95       	ret

00007398 <BootLoader_Indicator>:
	}

}

static void
BootLoader_Indicator(void){
    7398:	0f 93       	push	r16
    739a:	1f 93       	push	r17
    739c:	cf 93       	push	r28
    739e:	df 93       	push	r29
	UINT8_t i;

	static BLD_INDICATOR_STATE_t BootLoader_Indicator_Curr_State = BLD_INDICATOR_START;

	/*application pin indicator*/
	DIO_WRITE_PIN_VALUE(APP_PIN_INDICATOR, DIO_PIN_STATE_LOW);
    73a0:	81 e1       	ldi	r24, 0x11	; 17
    73a2:	60 e0       	ldi	r22, 0x00	; 0
    73a4:	0e 94 27 3c 	call	0x784e	; 0x784e <DIO_WRITE_PIN_VALUE>
	/*bootloader pin indicator*/
	DIO_WRITE_PIN_VALUE(BLD_PIN_INDICATOR, DIO_PIN_STATE_LOW);
    73a8:	80 e1       	ldi	r24, 0x10	; 16
    73aa:	60 e0       	ldi	r22, 0x00	; 0
    73ac:	0e 94 27 3c 	call	0x784e	; 0x784e <DIO_WRITE_PIN_VALUE>
    73b0:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<5; ++i){

		DIO_WRITE_PIN_VALUE(BLD_PIN_INDICATOR, 1^DIO_READ_PIN_VALUE(BLD_PIN_INDICATOR));
    73b2:	01 e0       	ldi	r16, 0x01	; 1
    73b4:	c8 ec       	ldi	r28, 0xC8	; 200
    73b6:	d0 e0       	ldi	r29, 0x00	; 0
    73b8:	80 e1       	ldi	r24, 0x10	; 16
    73ba:	0e 94 ca 3c 	call	0x7994	; 0x7994 <DIO_READ_PIN_VALUE>
    73be:	68 2f       	mov	r22, r24
    73c0:	60 27       	eor	r22, r16
    73c2:	80 e1       	ldi	r24, 0x10	; 16
    73c4:	0e 94 27 3c 	call	0x784e	; 0x784e <DIO_WRITE_PIN_VALUE>
    73c8:	80 e1       	ldi	r24, 0x10	; 16
    73ca:	97 e2       	ldi	r25, 0x27	; 39
    73cc:	fe 01       	movw	r30, r28
    73ce:	31 97       	sbiw	r30, 0x01	; 1
    73d0:	f1 f7       	brne	.-4      	; 0x73ce <BootLoader_Indicator+0x36>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    73d2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    73d4:	d9 f7       	brne	.-10     	; 0x73cc <BootLoader_Indicator+0x34>
	/*application pin indicator*/
	DIO_WRITE_PIN_VALUE(APP_PIN_INDICATOR, DIO_PIN_STATE_LOW);
	/*bootloader pin indicator*/
	DIO_WRITE_PIN_VALUE(BLD_PIN_INDICATOR, DIO_PIN_STATE_LOW);

	for(i=0; i<5; ++i){
    73d6:	1f 5f       	subi	r17, 0xFF	; 255
    73d8:	15 30       	cpi	r17, 0x05	; 5
    73da:	71 f7       	brne	.-36     	; 0x73b8 <BootLoader_Indicator+0x20>

		DIO_WRITE_PIN_VALUE(BLD_PIN_INDICATOR, 1^DIO_READ_PIN_VALUE(BLD_PIN_INDICATOR));
		_delay_ms(1000);

	}
	switch(BootLoader_Indicator_Curr_State){
    73dc:	80 91 2b 01 	lds	r24, 0x012B
    73e0:	88 23       	and	r24, r24
    73e2:	19 f0       	breq	.+6      	; 0x73ea <BootLoader_Indicator+0x52>
    73e4:	81 30       	cpi	r24, 0x01	; 1
    73e6:	71 f4       	brne	.+28     	; 0x7404 <BootLoader_Indicator+0x6c>
    73e8:	06 c0       	rjmp	.+12     	; 0x73f6 <BootLoader_Indicator+0x5e>

	case BLD_INDICATOR_START:

		DIO_WRITE_PIN_VALUE(BLD_PIN_INDICATOR, DIO_PIN_STATE_HIGH);
    73ea:	80 e1       	ldi	r24, 0x10	; 16
    73ec:	61 e0       	ldi	r22, 0x01	; 1
    73ee:	0e 94 27 3c 	call	0x784e	; 0x784e <DIO_WRITE_PIN_VALUE>

		BootLoader_Indicator_Curr_State = BLD_INDICATOR_END;
    73f2:	81 e0       	ldi	r24, 0x01	; 1
    73f4:	05 c0       	rjmp	.+10     	; 0x7400 <BootLoader_Indicator+0x68>

		break;

	case BLD_INDICATOR_END:

			DIO_WRITE_PIN_VALUE(BLD_PIN_INDICATOR, DIO_PIN_STATE_LOW);
    73f6:	80 e1       	ldi	r24, 0x10	; 16
    73f8:	60 e0       	ldi	r22, 0x00	; 0
    73fa:	0e 94 27 3c 	call	0x784e	; 0x784e <DIO_WRITE_PIN_VALUE>

			BootLoader_Indicator_Curr_State = BLD_INDICATOR_IDLE;
    73fe:	82 e0       	ldi	r24, 0x02	; 2
    7400:	80 93 2b 01 	sts	0x012B, r24
	default:

		break;
	}

}
    7404:	df 91       	pop	r29
    7406:	cf 91       	pop	r28
    7408:	1f 91       	pop	r17
    740a:	0f 91       	pop	r16
    740c:	08 95       	ret

0000740e <BOOTLOADER_Main>:


void
BOOTLOADER_Main(void){

	BootLoader_Indicator();
    740e:	0e 94 cc 39 	call	0x7398	; 0x7398 <BootLoader_Indicator>
	BOOTLOADER_STATE_Init();
    7412:	0e 94 54 3a 	call	0x74a8	; 0x74a8 <BOOTLOADER_STATE_Init>

	UDS_Req_Type = UDS_Read_Request();
    7416:	0e 94 11 3e 	call	0x7c22	; 0x7c22 <UDS_Read_Request>
    741a:	80 93 2d 01 	sts	0x012D, r24

	while (1) {

		Bootloader_State = BOOTLOADER_STATE_Get();
    741e:	0e 94 57 3a 	call	0x74ae	; 0x74ae <BOOTLOADER_STATE_Get>
    7422:	80 93 2c 01 	sts	0x012C, r24

		switch (Bootloader_State) {
    7426:	82 30       	cpi	r24, 0x02	; 2
    7428:	c1 f0       	breq	.+48     	; 0x745a <BOOTLOADER_Main+0x4c>
    742a:	83 30       	cpi	r24, 0x03	; 3
    742c:	28 f4       	brcc	.+10     	; 0x7438 <BOOTLOADER_Main+0x2a>
    742e:	88 23       	and	r24, r24
    7430:	41 f0       	breq	.+16     	; 0x7442 <BOOTLOADER_Main+0x34>
    7432:	81 30       	cpi	r24, 0x01	; 1
    7434:	a1 f7       	brne	.-24     	; 0x741e <BOOTLOADER_Main+0x10>
    7436:	0b c0       	rjmp	.+22     	; 0x744e <BOOTLOADER_Main+0x40>
    7438:	83 30       	cpi	r24, 0x03	; 3
    743a:	19 f1       	breq	.+70     	; 0x7482 <BOOTLOADER_Main+0x74>
    743c:	84 30       	cpi	r24, 0x04	; 4
    743e:	79 f7       	brne	.-34     	; 0x741e <BOOTLOADER_Main+0x10>
    7440:	28 c0       	rjmp	.+80     	; 0x7492 <BOOTLOADER_Main+0x84>

		case CHECKING_APPLICATION_EXIST:

			if (APP_EXIST == APP_Read_State()) {
    7442:	0e 94 a0 39 	call	0x7340	; 0x7340 <APP_Read_State>
    7446:	80 39       	cpi	r24, 0x90	; 144
    7448:	31 f4       	brne	.+12     	; 0x7456 <BOOTLOADER_Main+0x48>

				BOOTLOADER_STATE_Set(CHECKING_REQUEST_EXIST) ;
    744a:	81 e0       	ldi	r24, 0x01	; 1
    744c:	1f c0       	rjmp	.+62     	; 0x748c <BOOTLOADER_Main+0x7e>
			}

			break;
		case CHECKING_REQUEST_EXIST:

			if (UDS_Req_Type != UDS_NO_REQ) {
    744e:	80 91 2d 01 	lds	r24, 0x012D
    7452:	88 3f       	cpi	r24, 0xF8	; 248
    7454:	d1 f0       	breq	.+52     	; 0x748a <BOOTLOADER_Main+0x7c>

				BOOTLOADER_STATE_Set(CHECKING_TYPE_OF_REQUEST);
    7456:	82 e0       	ldi	r24, 0x02	; 2
    7458:	19 c0       	rjmp	.+50     	; 0x748c <BOOTLOADER_Main+0x7e>
			}

			break;
		case CHECKING_TYPE_OF_REQUEST:

			if (UDS_REQ_DATA_TRANSFER == UDS_Req_Type) {
    745a:	80 91 2d 01 	lds	r24, 0x012D
    745e:	80 33       	cpi	r24, 0x30	; 48
    7460:	31 f4       	brne	.+12     	; 0x746e <BOOTLOADER_Main+0x60>

				BOOTLOADER_STATE_Set(REQUEST_DATA_TRANSFER);
    7462:	83 e0       	ldi	r24, 0x03	; 3
    7464:	0e 94 5a 3a 	call	0x74b4	; 0x74b4 <BOOTLOADER_STATE_Set>

				UDS_Send_Positive_Response();
    7468:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <UDS_Send_Positive_Response>
    746c:	d8 cf       	rjmp	.-80     	; 0x741e <BOOTLOADER_Main+0x10>

			}else if(UDS_CFG_FEES == UDS_Req_Type){
    746e:	89 30       	cpi	r24, 0x09	; 9
    7470:	19 f4       	brne	.+6      	; 0x7478 <BOOTLOADER_Main+0x6a>

				/*get new fees*/
				CFG_PAR_Fees_Update();
    7472:	0e 94 9c 3b 	call	0x7738	; 0x7738 <CFG_PAR_Fees_Update>
    7476:	09 c0       	rjmp	.+18     	; 0x748a <BOOTLOADER_Main+0x7c>

				BOOTLOADER_STATE_Set(JMP_TO_APPLICATION_SECTION);

			}else if(UDS_CFG_BALANCE == UDS_Req_Type){
    7478:	80 3b       	cpi	r24, 0xB0	; 176
    747a:	89 f6       	brne	.-94     	; 0x741e <BOOTLOADER_Main+0x10>

				/*get new balance*/
				CFG_PAR_Balance_Update();
    747c:	0e 94 5d 3a 	call	0x74ba	; 0x74ba <CFG_PAR_Balance_Update>
    7480:	04 c0       	rjmp	.+8      	; 0x748a <BOOTLOADER_Main+0x7c>

			break;

		case REQUEST_DATA_TRANSFER:

			if (TRUE == APP_Rx()) {
    7482:	0e 94 66 39 	call	0x72cc	; 0x72cc <APP_Rx>
    7486:	81 30       	cpi	r24, 0x01	; 1
    7488:	51 f6       	brne	.-108    	; 0x741e <BOOTLOADER_Main+0x10>

				BOOTLOADER_STATE_Set(JMP_TO_APPLICATION_SECTION);
    748a:	84 e0       	ldi	r24, 0x04	; 4
    748c:	0e 94 5a 3a 	call	0x74b4	; 0x74b4 <BOOTLOADER_STATE_Set>
    7490:	c6 cf       	rjmp	.-116    	; 0x741e <BOOTLOADER_Main+0x10>
			}
			break;

		case JMP_TO_APPLICATION_SECTION:

			APP_Write_State(APP_EXIST);
    7492:	80 e9       	ldi	r24, 0x90	; 144
    7494:	0e 94 b4 39 	call	0x7368	; 0x7368 <APP_Write_State>

			UDS_Write_Request(UDS_NO_REQ);
    7498:	88 ef       	ldi	r24, 0xF8	; 248
    749a:	0e 94 2e 3e 	call	0x7c5c	; 0x7c5c <UDS_Write_Request>

			BootLoader_Indicator();
    749e:	0e 94 cc 39 	call	0x7398	; 0x7398 <BootLoader_Indicator>

			asm("jmp 0");
    74a2:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
    74a6:	bb cf       	rjmp	.-138    	; 0x741e <BOOTLOADER_Main+0x10>

000074a8 <BOOTLOADER_STATE_Init>:
static BOOTLOADER_STATE_t Bootloader_State;

void
BOOTLOADER_STATE_Init(void){

	Bootloader_State=CHECKING_APPLICATION_EXIST;
    74a8:	10 92 2e 01 	sts	0x012E, r1
}
    74ac:	08 95       	ret

000074ae <BOOTLOADER_STATE_Get>:

BOOTLOADER_STATE_t
BOOTLOADER_STATE_Get(void){

	return Bootloader_State;
}
    74ae:	80 91 2e 01 	lds	r24, 0x012E
    74b2:	08 95       	ret

000074b4 <BOOTLOADER_STATE_Set>:

void
BOOTLOADER_STATE_Set(BOOTLOADER_STATE_t State){

	Bootloader_State = State;
    74b4:	80 93 2e 01 	sts	0x012E, r24

}
    74b8:	08 95       	ret

000074ba <CFG_PAR_Balance_Update>:
	}

}

void
CFG_PAR_Balance_Update(void){
    74ba:	2f 92       	push	r2
    74bc:	3f 92       	push	r3
    74be:	4f 92       	push	r4
    74c0:	5f 92       	push	r5
    74c2:	6f 92       	push	r6
    74c4:	7f 92       	push	r7
    74c6:	8f 92       	push	r8
    74c8:	9f 92       	push	r9
    74ca:	af 92       	push	r10
    74cc:	bf 92       	push	r11
    74ce:	cf 92       	push	r12
    74d0:	df 92       	push	r13
    74d2:	ef 92       	push	r14
    74d4:	ff 92       	push	r15
    74d6:	0f 93       	push	r16
    74d8:	1f 93       	push	r17
    74da:	df 93       	push	r29
    74dc:	cf 93       	push	r28
    74de:	cd b7       	in	r28, 0x3d	; 61
    74e0:	de b7       	in	r29, 0x3e	; 62
    74e2:	29 97       	sbiw	r28, 0x09	; 9
    74e4:	0f b6       	in	r0, 0x3f	; 63
    74e6:	f8 94       	cli
    74e8:	de bf       	out	0x3e, r29	; 62
    74ea:	0f be       	out	0x3f, r0	; 63
    74ec:	cd bf       	out	0x3d, r28	; 61
    74ee:	2a e5       	ldi	r18, 0x5A	; 90
    74f0:	30 e0       	ldi	r19, 0x00	; 0
    74f2:	39 87       	std	Y+9, r19	; 0x09
    74f4:	28 87       	std	Y+8, r18	; 0x08
    74f6:	22 24       	eor	r2, r2
    74f8:	33 24       	eor	r3, r3
    74fa:	55 24       	eor	r5, r5
    74fc:	77 24       	eor	r7, r7
    74fe:	99 24       	eor	r9, r9
    7500:	cc 24       	eor	r12, r12
    7502:	dd 24       	eor	r13, r13
    7504:	10 e0       	ldi	r17, 0x00	; 0
    7506:	ee 24       	eor	r14, r14
    7508:	ff 24       	eor	r15, r15

	UINT64_t Balance = 0;

	for (Idx = 0; Idx < BALANCE_NO_OF_BYTES; ++Idx) {

		Data = (UINT64_t)FLASH_Data_Read(Curr_Address);
    750a:	88 85       	ldd	r24, Y+8	; 0x08
    750c:	99 85       	ldd	r25, Y+9	; 0x09
    750e:	0e 94 57 3d 	call	0x7aae	; 0x7aae <FLASH_Data_Read>
    7512:	e0 e1       	ldi	r30, 0x10	; 16
    7514:	f7 e2       	ldi	r31, 0x27	; 39
    7516:	a8 ec       	ldi	r26, 0xC8	; 200
    7518:	b0 e0       	ldi	r27, 0x00	; 0
    751a:	11 97       	sbiw	r26, 0x01	; 1
    751c:	f1 f7       	brne	.-4      	; 0x751a <CFG_PAR_Balance_Update+0x60>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    751e:	31 97       	sbiw	r30, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7520:	d1 f7       	brne	.-12     	; 0x7516 <CFG_PAR_Balance_Update+0x5c>

		_delay_ms(1000);

		Balance |= (Data << (Idx*8));
    7522:	28 2f       	mov	r18, r24
    7524:	30 e0       	ldi	r19, 0x00	; 0
    7526:	40 e0       	ldi	r20, 0x00	; 0
    7528:	50 e0       	ldi	r21, 0x00	; 0
    752a:	60 e0       	ldi	r22, 0x00	; 0
    752c:	70 e0       	ldi	r23, 0x00	; 0
    752e:	80 e0       	ldi	r24, 0x00	; 0
    7530:	90 e0       	ldi	r25, 0x00	; 0
    7532:	0e 2d       	mov	r16, r14
    7534:	0e 94 c8 38 	call	0x7190	; 0x7190 <__ashldi3>
    7538:	b2 2e       	mov	r11, r18
    753a:	a3 2e       	mov	r10, r19
    753c:	84 2e       	mov	r8, r20
    753e:	65 2e       	mov	r6, r21
    7540:	46 2e       	mov	r4, r22
    7542:	b2 28       	or	r11, r2
    7544:	a3 28       	or	r10, r3
    7546:	85 28       	or	r8, r5
    7548:	67 28       	or	r6, r7
    754a:	49 28       	or	r4, r9
    754c:	37 2f       	mov	r19, r23
    754e:	3c 29       	or	r19, r12
    7550:	3d 83       	std	Y+5, r19	; 0x05
    7552:	d8 2a       	or	r13, r24
    7554:	de 82       	std	Y+6, r13	; 0x06
    7556:	19 2b       	or	r17, r25
    7558:	1f 83       	std	Y+7, r17	; 0x07
    755a:	2b 2c       	mov	r2, r11
    755c:	3a 2c       	mov	r3, r10
    755e:	58 2c       	mov	r5, r8
    7560:	76 2c       	mov	r7, r6
    7562:	94 2c       	mov	r9, r4
    7564:	c3 2e       	mov	r12, r19
    7566:	88 e0       	ldi	r24, 0x08	; 8
    7568:	90 e0       	ldi	r25, 0x00	; 0
    756a:	e8 0e       	add	r14, r24
    756c:	f9 1e       	adc	r15, r25

	UINT16_t Curr_Address = BALANCE_BASE_ADDRESS;

	UINT64_t Balance = 0;

	for (Idx = 0; Idx < BALANCE_NO_OF_BYTES; ++Idx) {
    756e:	e8 85       	ldd	r30, Y+8	; 0x08
    7570:	f9 85       	ldd	r31, Y+9	; 0x09
    7572:	e1 36       	cpi	r30, 0x61	; 97
    7574:	f1 05       	cpc	r31, r1
    7576:	21 f0       	breq	.+8      	; 0x7580 <CFG_PAR_Balance_Update+0xc6>

		_delay_ms(1000);

		Balance |= (Data << (Idx*8));

		++Curr_Address;
    7578:	31 96       	adiw	r30, 0x01	; 1
    757a:	f9 87       	std	Y+9, r31	; 0x09
    757c:	e8 87       	std	Y+8, r30	; 0x08
    757e:	c5 cf       	rjmp	.-118    	; 0x750a <CFG_PAR_Balance_Update+0x50>
	UINT64_t Data=0;
	UINT8_t Idx;

	UINT64_t Balance = 0;

	UDS_Send_Positive_Response();
    7580:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <UDS_Send_Positive_Response>
    7584:	ee 24       	eor	r14, r14
    7586:	19 82       	std	Y+1, r1	; 0x01
    7588:	1a 82       	std	Y+2, r1	; 0x02
    758a:	1b 82       	std	Y+3, r1	; 0x03
    758c:	1c 82       	std	Y+4, r1	; 0x04
    758e:	22 24       	eor	r2, r2
    7590:	33 24       	eor	r3, r3
    7592:	55 24       	eor	r5, r5
    7594:	19 86       	std	Y+9, r1	; 0x09
    7596:	18 86       	std	Y+8, r1	; 0x08

	for (Idx = 0; Idx < BALANCE_NO_OF_BYTES; ++Idx) {

		Data = (UINT64_t)URT_Rx_Char();
    7598:	0e 94 67 3e 	call	0x7cce	; 0x7cce <URT_Rx_Char>

		Balance |= (Data << (Idx*8));
    759c:	28 2f       	mov	r18, r24
    759e:	30 e0       	ldi	r19, 0x00	; 0
    75a0:	40 e0       	ldi	r20, 0x00	; 0
    75a2:	50 e0       	ldi	r21, 0x00	; 0
    75a4:	60 e0       	ldi	r22, 0x00	; 0
    75a6:	70 e0       	ldi	r23, 0x00	; 0
    75a8:	80 e0       	ldi	r24, 0x00	; 0
    75aa:	90 e0       	ldi	r25, 0x00	; 0
    75ac:	08 85       	ldd	r16, Y+8	; 0x08
    75ae:	0e 94 c8 38 	call	0x7190	; 0x7190 <__ashldi3>
    75b2:	03 2f       	mov	r16, r19
    75b4:	f4 2e       	mov	r15, r20
    75b6:	15 2f       	mov	r17, r21
    75b8:	d6 2e       	mov	r13, r22
    75ba:	c7 2e       	mov	r12, r23
    75bc:	f9 81       	ldd	r31, Y+1	; 0x01
    75be:	0f 2b       	or	r16, r31
    75c0:	3a 81       	ldd	r19, Y+2	; 0x02
    75c2:	f3 2a       	or	r15, r19
    75c4:	eb 81       	ldd	r30, Y+3	; 0x03
    75c6:	1e 2b       	or	r17, r30
    75c8:	fc 81       	ldd	r31, Y+4	; 0x04
    75ca:	df 2a       	or	r13, r31
    75cc:	c2 28       	or	r12, r2
    75ce:	73 2c       	mov	r7, r3
    75d0:	78 2a       	or	r7, r24
    75d2:	95 2c       	mov	r9, r5
    75d4:	99 2a       	or	r9, r25
    75d6:	e2 2a       	or	r14, r18
    75d8:	09 83       	std	Y+1, r16	; 0x01
    75da:	fa 82       	std	Y+2, r15	; 0x02
    75dc:	1b 83       	std	Y+3, r17	; 0x03
    75de:	dc 82       	std	Y+4, r13	; 0x04
    75e0:	2c 2c       	mov	r2, r12
    75e2:	37 2c       	mov	r3, r7
    75e4:	59 2c       	mov	r5, r9

		UDS_Send_Positive_Response();
    75e6:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <UDS_Send_Positive_Response>
    75ea:	28 85       	ldd	r18, Y+8	; 0x08
    75ec:	39 85       	ldd	r19, Y+9	; 0x09
    75ee:	28 5f       	subi	r18, 0xF8	; 248
    75f0:	3f 4f       	sbci	r19, 0xFF	; 255
    75f2:	39 87       	std	Y+9, r19	; 0x09
    75f4:	28 87       	std	Y+8, r18	; 0x08

	UINT64_t Balance = 0;

	UDS_Send_Positive_Response();

	for (Idx = 0; Idx < BALANCE_NO_OF_BYTES; ++Idx) {
    75f6:	20 34       	cpi	r18, 0x40	; 64
    75f8:	31 05       	cpc	r19, r1
    75fa:	71 f6       	brne	.-100    	; 0x7598 <CFG_PAR_Balance_Update+0xde>

	UINT64_t Balance=0;

	Balance = Get_Last_Balance();

	Balance += Get_Current_Balance();
    75fc:	2e 2c       	mov	r2, r14
    75fe:	2b 0c       	add	r2, r11
    7600:	81 e0       	ldi	r24, 0x01	; 1
    7602:	2e 14       	cp	r2, r14
    7604:	08 f0       	brcs	.+2      	; 0x7608 <CFG_PAR_Balance_Update+0x14e>
    7606:	80 e0       	ldi	r24, 0x00	; 0
    7608:	30 2f       	mov	r19, r16
    760a:	3a 0d       	add	r19, r10
    760c:	91 e0       	ldi	r25, 0x01	; 1
    760e:	30 17       	cp	r19, r16
    7610:	08 f0       	brcs	.+2      	; 0x7614 <CFG_PAR_Balance_Update+0x15a>
    7612:	90 e0       	ldi	r25, 0x00	; 0
    7614:	38 2e       	mov	r3, r24
    7616:	33 0e       	add	r3, r19
    7618:	81 e0       	ldi	r24, 0x01	; 1
    761a:	33 16       	cp	r3, r19
    761c:	08 f0       	brcs	.+2      	; 0x7620 <CFG_PAR_Balance_Update+0x166>
    761e:	80 e0       	ldi	r24, 0x00	; 0
    7620:	98 2b       	or	r25, r24
    7622:	4f 2d       	mov	r20, r15
    7624:	48 0d       	add	r20, r8
    7626:	21 e0       	ldi	r18, 0x01	; 1
    7628:	4f 15       	cp	r20, r15
    762a:	08 f0       	brcs	.+2      	; 0x762e <CFG_PAR_Balance_Update+0x174>
    762c:	20 e0       	ldi	r18, 0x00	; 0
    762e:	59 2e       	mov	r5, r25
    7630:	54 0e       	add	r5, r20
    7632:	81 e0       	ldi	r24, 0x01	; 1
    7634:	54 16       	cp	r5, r20
    7636:	08 f0       	brcs	.+2      	; 0x763a <CFG_PAR_Balance_Update+0x180>
    7638:	80 e0       	ldi	r24, 0x00	; 0
    763a:	28 2b       	or	r18, r24
    763c:	51 2f       	mov	r21, r17
    763e:	56 0d       	add	r21, r6
    7640:	91 e0       	ldi	r25, 0x01	; 1
    7642:	51 17       	cp	r21, r17
    7644:	08 f0       	brcs	.+2      	; 0x7648 <CFG_PAR_Balance_Update+0x18e>
    7646:	90 e0       	ldi	r25, 0x00	; 0
    7648:	62 2e       	mov	r6, r18
    764a:	65 0e       	add	r6, r21
    764c:	81 e0       	ldi	r24, 0x01	; 1
    764e:	65 16       	cp	r6, r21
    7650:	08 f0       	brcs	.+2      	; 0x7654 <CFG_PAR_Balance_Update+0x19a>
    7652:	80 e0       	ldi	r24, 0x00	; 0
    7654:	98 2b       	or	r25, r24
    7656:	6d 2d       	mov	r22, r13
    7658:	64 0d       	add	r22, r4
    765a:	21 e0       	ldi	r18, 0x01	; 1
    765c:	6d 15       	cp	r22, r13
    765e:	08 f0       	brcs	.+2      	; 0x7662 <CFG_PAR_Balance_Update+0x1a8>
    7660:	20 e0       	ldi	r18, 0x00	; 0
    7662:	89 2e       	mov	r8, r25
    7664:	86 0e       	add	r8, r22
    7666:	81 e0       	ldi	r24, 0x01	; 1
    7668:	86 16       	cp	r8, r22
    766a:	08 f0       	brcs	.+2      	; 0x766e <CFG_PAR_Balance_Update+0x1b4>
    766c:	80 e0       	ldi	r24, 0x00	; 0
    766e:	28 2b       	or	r18, r24
    7670:	7d 81       	ldd	r23, Y+5	; 0x05
    7672:	7c 0d       	add	r23, r12
    7674:	81 e0       	ldi	r24, 0x01	; 1
    7676:	7c 15       	cp	r23, r12
    7678:	08 f0       	brcs	.+2      	; 0x767c <CFG_PAR_Balance_Update+0x1c2>
    767a:	80 e0       	ldi	r24, 0x00	; 0
    767c:	c2 2e       	mov	r12, r18
    767e:	c7 0e       	add	r12, r23
    7680:	91 e0       	ldi	r25, 0x01	; 1
    7682:	c7 16       	cp	r12, r23
    7684:	08 f0       	brcs	.+2      	; 0x7688 <CFG_PAR_Balance_Update+0x1ce>
    7686:	90 e0       	ldi	r25, 0x00	; 0
    7688:	89 2b       	or	r24, r25
    768a:	2e 81       	ldd	r18, Y+6	; 0x06
    768c:	27 0d       	add	r18, r7
    768e:	31 e0       	ldi	r19, 0x01	; 1
    7690:	27 15       	cp	r18, r7
    7692:	08 f0       	brcs	.+2      	; 0x7696 <CFG_PAR_Balance_Update+0x1dc>
    7694:	30 e0       	ldi	r19, 0x00	; 0
    7696:	d8 2e       	mov	r13, r24
    7698:	d2 0e       	add	r13, r18
    769a:	91 e0       	ldi	r25, 0x01	; 1
    769c:	d2 16       	cp	r13, r18
    769e:	08 f0       	brcs	.+2      	; 0x76a2 <CFG_PAR_Balance_Update+0x1e8>
    76a0:	90 e0       	ldi	r25, 0x00	; 0
    76a2:	13 2f       	mov	r17, r19
    76a4:	19 2b       	or	r17, r25
    76a6:	3f 81       	ldd	r19, Y+7	; 0x07
    76a8:	93 0e       	add	r9, r19
    76aa:	19 0d       	add	r17, r9
    76ac:	8a e5       	ldi	r24, 0x5A	; 90
    76ae:	90 e0       	ldi	r25, 0x00	; 0
    76b0:	99 87       	std	Y+9, r25	; 0x09
    76b2:	88 87       	std	Y+8, r24	; 0x08
    76b4:	ee 24       	eor	r14, r14
    76b6:	ff 24       	eor	r15, r15
    76b8:	88 ec       	ldi	r24, 0xC8	; 200
    76ba:	a8 2e       	mov	r10, r24
    76bc:	b1 2c       	mov	r11, r1

	for (Idx = 0; Idx < BALANCE_NO_OF_BYTES; ++Idx) {

			Data = Balance>>(Idx*8);

			FLASH_Data_Write(Curr_Address, Data);
    76be:	91 01       	movw	r18, r2
    76c0:	45 2d       	mov	r20, r5
    76c2:	56 2d       	mov	r21, r6
    76c4:	68 2d       	mov	r22, r8
    76c6:	7c 2d       	mov	r23, r12
    76c8:	8d 2d       	mov	r24, r13
    76ca:	91 2f       	mov	r25, r17
    76cc:	0e 2d       	mov	r16, r14
    76ce:	0e 94 49 38 	call	0x7092	; 0x7092 <__lshrdi3>
    76d2:	88 85       	ldd	r24, Y+8	; 0x08
    76d4:	99 85       	ldd	r25, Y+9	; 0x09
    76d6:	62 2f       	mov	r22, r18
    76d8:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <FLASH_Data_Write>
    76dc:	80 e1       	ldi	r24, 0x10	; 16
    76de:	97 e2       	ldi	r25, 0x27	; 39
    76e0:	f5 01       	movw	r30, r10
    76e2:	31 97       	sbiw	r30, 0x01	; 1
    76e4:	f1 f7       	brne	.-4      	; 0x76e2 <CFG_PAR_Balance_Update+0x228>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    76e6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    76e8:	d9 f7       	brne	.-10     	; 0x76e0 <CFG_PAR_Balance_Update+0x226>
    76ea:	e8 e0       	ldi	r30, 0x08	; 8
    76ec:	f0 e0       	ldi	r31, 0x00	; 0
    76ee:	ee 0e       	add	r14, r30
    76f0:	ff 1e       	adc	r15, r31

	Balance = Get_Last_Balance();

	Balance += Get_Current_Balance();

	for (Idx = 0; Idx < BALANCE_NO_OF_BYTES; ++Idx) {
    76f2:	28 85       	ldd	r18, Y+8	; 0x08
    76f4:	39 85       	ldd	r19, Y+9	; 0x09
    76f6:	21 36       	cpi	r18, 0x61	; 97
    76f8:	31 05       	cpc	r19, r1
    76fa:	29 f0       	breq	.+10     	; 0x7706 <CFG_PAR_Balance_Update+0x24c>

			FLASH_Data_Write(Curr_Address, Data);

			_delay_ms(1000);

			++Curr_Address;
    76fc:	2f 5f       	subi	r18, 0xFF	; 255
    76fe:	3f 4f       	sbci	r19, 0xFF	; 255
    7700:	39 87       	std	Y+9, r19	; 0x09
    7702:	28 87       	std	Y+8, r18	; 0x08
    7704:	dc cf       	rjmp	.-72     	; 0x76be <CFG_PAR_Balance_Update+0x204>

		}

}
    7706:	29 96       	adiw	r28, 0x09	; 9
    7708:	0f b6       	in	r0, 0x3f	; 63
    770a:	f8 94       	cli
    770c:	de bf       	out	0x3e, r29	; 62
    770e:	0f be       	out	0x3f, r0	; 63
    7710:	cd bf       	out	0x3d, r28	; 61
    7712:	cf 91       	pop	r28
    7714:	df 91       	pop	r29
    7716:	1f 91       	pop	r17
    7718:	0f 91       	pop	r16
    771a:	ff 90       	pop	r15
    771c:	ef 90       	pop	r14
    771e:	df 90       	pop	r13
    7720:	cf 90       	pop	r12
    7722:	bf 90       	pop	r11
    7724:	af 90       	pop	r10
    7726:	9f 90       	pop	r9
    7728:	8f 90       	pop	r8
    772a:	7f 90       	pop	r7
    772c:	6f 90       	pop	r6
    772e:	5f 90       	pop	r5
    7730:	4f 90       	pop	r4
    7732:	3f 90       	pop	r3
    7734:	2f 90       	pop	r2
    7736:	08 95       	ret

00007738 <CFG_PAR_Fees_Update>:
	UINT8_t Data;
	UINT8_t Idx;

	UINT16_t Curr_Address=FEES_BASE_ADDRESS;

	UDS_Send_Positive_Response();
    7738:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <UDS_Send_Positive_Response>

	for(Idx=0; Idx< FEES_NO_OF_BYTES; ++Idx){

		Data=URT_Rx_Char();
    773c:	0e 94 67 3e 	call	0x7cce	; 0x7cce <URT_Rx_Char>
    7740:	68 2f       	mov	r22, r24

		FLASH_Data_Write(Curr_Address, Data);
    7742:	86 e4       	ldi	r24, 0x46	; 70
    7744:	90 e0       	ldi	r25, 0x00	; 0
    7746:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <FLASH_Data_Write>
    774a:	80 e1       	ldi	r24, 0x10	; 16
    774c:	97 e2       	ldi	r25, 0x27	; 39
    774e:	28 ec       	ldi	r18, 0xC8	; 200
    7750:	30 e0       	ldi	r19, 0x00	; 0
    7752:	f9 01       	movw	r30, r18
    7754:	31 97       	sbiw	r30, 0x01	; 1
    7756:	f1 f7       	brne	.-4      	; 0x7754 <CFG_PAR_Fees_Update+0x1c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7758:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    775a:	d9 f7       	brne	.-10     	; 0x7752 <CFG_PAR_Fees_Update+0x1a>

		_delay_ms(1000);

		++Curr_Address;

		UDS_Send_Positive_Response();
    775c:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <UDS_Send_Positive_Response>
	}

}
    7760:	08 95       	ret

00007762 <Asci2Hex>:
}


UINT8_t
Asci2Hex(UINT8_t MSB4, UINT8_t LSB4)
{
    7762:	98 2f       	mov	r25, r24
	UINT8_t Hex=0;
	if( (MSB4 >='0' && MSB4 <='9') && (LSB4 >='0' && LSB4 <='9') ){
    7764:	80 53       	subi	r24, 0x30	; 48
    7766:	26 2f       	mov	r18, r22
    7768:	20 53       	subi	r18, 0x30	; 48
    776a:	8a 30       	cpi	r24, 0x0A	; 10
    776c:	78 f4       	brcc	.+30     	; 0x778c <Asci2Hex+0x2a>
    776e:	2a 30       	cpi	r18, 0x0A	; 10
    7770:	20 f4       	brcc	.+8      	; 0x777a <Asci2Hex+0x18>
		Hex= ( (MSB4-'0')<<4 ) | (LSB4-'0');
    7772:	92 95       	swap	r25
    7774:	90 7f       	andi	r25, 0xF0	; 240
    7776:	92 2b       	or	r25, r18
    7778:	2c c0       	rjmp	.+88     	; 0x77d2 <Asci2Hex+0x70>
	}else if( (MSB4 >='0' && MSB4 <='9') ){
		if(LSB4 >='A' && LSB4 <='Z'){
    777a:	86 2f       	mov	r24, r22
    777c:	81 54       	subi	r24, 0x41	; 65
    777e:	8a 31       	cpi	r24, 0x1A	; 26
    7780:	38 f5       	brcc	.+78     	; 0x77d0 <Asci2Hex+0x6e>
			Hex= ( (MSB4-'0')<<4 ) | (LSB4-'A'+10);
    7782:	92 95       	swap	r25
    7784:	90 7f       	andi	r25, 0xF0	; 240
    7786:	67 53       	subi	r22, 0x37	; 55
    7788:	96 2b       	or	r25, r22
    778a:	23 c0       	rjmp	.+70     	; 0x77d2 <Asci2Hex+0x70>
    778c:	89 2f       	mov	r24, r25
    778e:	81 54       	subi	r24, 0x41	; 65
		}
	}else if( (LSB4 >='0' && LSB4 <='9') ){
    7790:	2a 30       	cpi	r18, 0x0A	; 10
    7792:	60 f4       	brcc	.+24     	; 0x77ac <Asci2Hex+0x4a>
		if(MSB4 >='A' && MSB4 <='Z'){
    7794:	8a 31       	cpi	r24, 0x1A	; 26
    7796:	e0 f4       	brcc	.+56     	; 0x77d0 <Asci2Hex+0x6e>
			Hex= ( (MSB4-'A'+10)<<4 ) | (LSB4-'0');
    7798:	89 2f       	mov	r24, r25
    779a:	90 e0       	ldi	r25, 0x00	; 0
    779c:	c7 97       	sbiw	r24, 0x37	; 55
    779e:	34 e0       	ldi	r19, 0x04	; 4
    77a0:	88 0f       	add	r24, r24
    77a2:	99 1f       	adc	r25, r25
    77a4:	3a 95       	dec	r19
    77a6:	e1 f7       	brne	.-8      	; 0x77a0 <Asci2Hex+0x3e>
    77a8:	92 2f       	mov	r25, r18
    77aa:	10 c0       	rjmp	.+32     	; 0x77cc <Asci2Hex+0x6a>
		}
	}else if( (MSB4 >='A' && MSB4 <='Z') && (LSB4 >='A' && LSB4 <='Z') ){
    77ac:	8a 31       	cpi	r24, 0x1A	; 26
    77ae:	80 f4       	brcc	.+32     	; 0x77d0 <Asci2Hex+0x6e>
    77b0:	86 2f       	mov	r24, r22
    77b2:	81 54       	subi	r24, 0x41	; 65
    77b4:	8a 31       	cpi	r24, 0x1A	; 26
    77b6:	60 f4       	brcc	.+24     	; 0x77d0 <Asci2Hex+0x6e>
		Hex= ( (MSB4-'A'+10)<<4 ) | (LSB4-'A'+10);
    77b8:	89 2f       	mov	r24, r25
    77ba:	90 e0       	ldi	r25, 0x00	; 0
    77bc:	c7 97       	sbiw	r24, 0x37	; 55
    77be:	24 e0       	ldi	r18, 0x04	; 4
    77c0:	88 0f       	add	r24, r24
    77c2:	99 1f       	adc	r25, r25
    77c4:	2a 95       	dec	r18
    77c6:	e1 f7       	brne	.-8      	; 0x77c0 <Asci2Hex+0x5e>
    77c8:	96 2f       	mov	r25, r22
    77ca:	97 53       	subi	r25, 0x37	; 55
    77cc:	98 2b       	or	r25, r24
    77ce:	01 c0       	rjmp	.+2      	; 0x77d2 <Asci2Hex+0x70>
    77d0:	90 e0       	ldi	r25, 0x00	; 0
	}else {

	}
	return Hex;
}
    77d2:	89 2f       	mov	r24, r25
    77d4:	08 95       	ret

000077d6 <CRC_Check>:
#include "STD_BITS.h"
#include "CRC.h"

BOOL_t
CRC_Check(UINT8_t*Record)
{
    77d6:	af 92       	push	r10
    77d8:	bf 92       	push	r11
    77da:	cf 92       	push	r12
    77dc:	df 92       	push	r13
    77de:	ef 92       	push	r14
    77e0:	ff 92       	push	r15
    77e2:	0f 93       	push	r16
    77e4:	1f 93       	push	r17
    77e6:	cf 93       	push	r28
    77e8:	df 93       	push	r29
    77ea:	5c 01       	movw	r10, r24
    77ec:	ec 01       	movw	r28, r24
    77ee:	ee 24       	eor	r14, r14
    77f0:	ff 24       	eor	r15, r15
    77f2:	87 01       	movw	r16, r14
    77f4:	e0 e0       	ldi	r30, 0x00	; 0
    77f6:	f0 e0       	ldi	r31, 0x00	; 0
    77f8:	0a c0       	rjmp	.+20     	; 0x780e <CRC_Check+0x38>
	UINT32_t Sum = 0;
	UINT16_t Idx = 0;
	UINT8_t Curr_Crc;

	while (Record[Idx + 2] != STOP_CHAR) {
		Sum += Asci2Hex(Record[Idx], Record[1 + Idx]);
    77fa:	88 81       	ld	r24, Y
    77fc:	69 81       	ldd	r22, Y+1	; 0x01
    77fe:	0e 94 b1 3b 	call	0x7762	; 0x7762 <Asci2Hex>
    7802:	e8 0e       	add	r14, r24
    7804:	f1 1c       	adc	r15, r1
    7806:	01 1d       	adc	r16, r1
    7808:	11 1d       	adc	r17, r1
    780a:	22 96       	adiw	r28, 0x02	; 2
    780c:	f6 01       	movw	r30, r12
	BOOL_t State = FALSE;
	UINT32_t Sum = 0;
	UINT16_t Idx = 0;
	UINT8_t Curr_Crc;

	while (Record[Idx + 2] != STOP_CHAR) {
    780e:	42 e0       	ldi	r20, 0x02	; 2
    7810:	c4 2e       	mov	r12, r20
    7812:	d1 2c       	mov	r13, r1
    7814:	ce 0e       	add	r12, r30
    7816:	df 1e       	adc	r13, r31
    7818:	8a 81       	ldd	r24, Y+2	; 0x02
    781a:	8e 32       	cpi	r24, 0x2E	; 46
    781c:	71 f7       	brne	.-36     	; 0x77fa <CRC_Check+0x24>
		Sum += Asci2Hex(Record[Idx], Record[1 + Idx]);
		Idx += 2;
	}
	Sum &= 0xff;
	Curr_Crc = 0x100UL - Sum;
	if (Curr_Crc == Asci2Hex(Record[Idx], Record[1 + Idx])) {
    781e:	ea 0d       	add	r30, r10
    7820:	fb 1d       	adc	r31, r11
    7822:	80 81       	ld	r24, Z
    7824:	61 81       	ldd	r22, Z+1	; 0x01
    7826:	0e 94 b1 3b 	call	0x7762	; 0x7762 <Asci2Hex>
    782a:	20 e0       	ldi	r18, 0x00	; 0
    782c:	9e 2d       	mov	r25, r14
    782e:	91 95       	neg	r25
    7830:	98 17       	cp	r25, r24
    7832:	09 f4       	brne	.+2      	; 0x7836 <CRC_Check+0x60>
    7834:	21 e0       	ldi	r18, 0x01	; 1
		State = TRUE;
	}

	return State;

}
    7836:	82 2f       	mov	r24, r18
    7838:	df 91       	pop	r29
    783a:	cf 91       	pop	r28
    783c:	1f 91       	pop	r17
    783e:	0f 91       	pop	r16
    7840:	ff 90       	pop	r15
    7842:	ef 90       	pop	r14
    7844:	df 90       	pop	r13
    7846:	cf 90       	pop	r12
    7848:	bf 90       	pop	r11
    784a:	af 90       	pop	r10
    784c:	08 95       	ret

0000784e <DIO_WRITE_PIN_VALUE>:
			break;
		}
	}
}
/****************************************************************************/
void DIO_WRITE_PIN_VALUE(const DIO_PIN_ID_t PIN_ID, const DIO_PIN_STATE_t PIN_STATE){
    784e:	38 2f       	mov	r19, r24
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { PORTA_ADD, PORTB_ADD, PORTC_ADD, PORTD_ADD };
	DIO_PORT_ID_t Port_Id = PIN_ID / 8;
    7850:	e8 2f       	mov	r30, r24
    7852:	e6 95       	lsr	r30
    7854:	e6 95       	lsr	r30
    7856:	e6 95       	lsr	r30
	switch (PIN_STATE) {
    7858:	66 23       	and	r22, r22
    785a:	b1 f0       	breq	.+44     	; 0x7888 <DIO_WRITE_PIN_VALUE+0x3a>
    785c:	61 30       	cpi	r22, 0x01	; 1
    785e:	41 f5       	brne	.+80     	; 0x78b0 <DIO_WRITE_PIN_VALUE+0x62>
	case DIO_PIN_STATE_HIGH:
		SET_BIT(*Reg[Port_Id], PIN_ID % 8);
    7860:	f0 e0       	ldi	r31, 0x00	; 0
    7862:	ee 0f       	add	r30, r30
    7864:	ff 1f       	adc	r31, r31
    7866:	e8 56       	subi	r30, 0x68	; 104
    7868:	ff 4f       	sbci	r31, 0xFF	; 255
    786a:	01 90       	ld	r0, Z+
    786c:	f0 81       	ld	r31, Z
    786e:	e0 2d       	mov	r30, r0
    7870:	20 81       	ld	r18, Z
    7872:	37 70       	andi	r19, 0x07	; 7
    7874:	81 e0       	ldi	r24, 0x01	; 1
    7876:	90 e0       	ldi	r25, 0x00	; 0
    7878:	02 c0       	rjmp	.+4      	; 0x787e <DIO_WRITE_PIN_VALUE+0x30>
    787a:	88 0f       	add	r24, r24
    787c:	99 1f       	adc	r25, r25
    787e:	3a 95       	dec	r19
    7880:	e2 f7       	brpl	.-8      	; 0x787a <DIO_WRITE_PIN_VALUE+0x2c>
    7882:	28 2b       	or	r18, r24
    7884:	20 83       	st	Z, r18
    7886:	08 95       	ret
		break;
	case DIO_PIN_STATE_LOW:
		CLEAR_BIT(*Reg[Port_Id], PIN_ID % 8);
    7888:	f0 e0       	ldi	r31, 0x00	; 0
    788a:	ee 0f       	add	r30, r30
    788c:	ff 1f       	adc	r31, r31
    788e:	e8 56       	subi	r30, 0x68	; 104
    7890:	ff 4f       	sbci	r31, 0xFF	; 255
    7892:	01 90       	ld	r0, Z+
    7894:	f0 81       	ld	r31, Z
    7896:	e0 2d       	mov	r30, r0
    7898:	20 81       	ld	r18, Z
    789a:	37 70       	andi	r19, 0x07	; 7
    789c:	81 e0       	ldi	r24, 0x01	; 1
    789e:	90 e0       	ldi	r25, 0x00	; 0
    78a0:	02 c0       	rjmp	.+4      	; 0x78a6 <DIO_WRITE_PIN_VALUE+0x58>
    78a2:	88 0f       	add	r24, r24
    78a4:	99 1f       	adc	r25, r25
    78a6:	3a 95       	dec	r19
    78a8:	e2 f7       	brpl	.-8      	; 0x78a2 <DIO_WRITE_PIN_VALUE+0x54>
    78aa:	80 95       	com	r24
    78ac:	82 23       	and	r24, r18
    78ae:	80 83       	st	Z, r24
    78b0:	08 95       	ret

000078b2 <DIO_INIT>:
#include "DIO_CFG.h"
#include "DIO.h"
/****************************************************************************/

void DIO_INIT(void)
{
    78b2:	ef 92       	push	r14
    78b4:	ff 92       	push	r15
    78b6:	1f 93       	push	r17
    78b8:	cf 93       	push	r28
    78ba:	df 93       	push	r29
    78bc:	10 e0       	ldi	r17, 0x00	; 0
    78be:	c0 e0       	ldi	r28, 0x00	; 0
    78c0:	d0 e0       	ldi	r29, 0x00	; 0
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { DDRA_ADD, DDRB_ADD, DDRC_ADD, DDRD_ADD };
	for (Pin_Id = DIO_PINA0; Pin_Id < DIO_MAX_PINS; Pin_Id++) {
		Port_Id = Pin_Id / 8;
		switch (Pin_Direction[Pin_Id]) {
		case DIO_PIN_DIRECTION_OUTPUT:
			SET_BIT(*Reg[Port_Id], Pin_Id % 8);
    78c2:	51 e0       	ldi	r21, 0x01	; 1
    78c4:	e5 2e       	mov	r14, r21
    78c6:	f1 2c       	mov	r15, r1
{
	DIO_PIN_ID_t Pin_Id;
	DIO_PORT_ID_t Port_Id;
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { DDRA_ADD, DDRB_ADD, DDRC_ADD, DDRD_ADD };
	for (Pin_Id = DIO_PINA0; Pin_Id < DIO_MAX_PINS; Pin_Id++) {
		Port_Id = Pin_Id / 8;
    78c8:	21 2f       	mov	r18, r17
    78ca:	26 95       	lsr	r18
    78cc:	26 95       	lsr	r18
    78ce:	26 95       	lsr	r18
		switch (Pin_Direction[Pin_Id]) {
    78d0:	81 2f       	mov	r24, r17
    78d2:	90 e0       	ldi	r25, 0x00	; 0
    78d4:	fc 01       	movw	r30, r24
    78d6:	e0 5a       	subi	r30, 0xA0	; 160
    78d8:	ff 4f       	sbci	r31, 0xFF	; 255
    78da:	e0 81       	ld	r30, Z
    78dc:	e1 30       	cpi	r30, 0x01	; 1
    78de:	31 f0       	breq	.+12     	; 0x78ec <DIO_INIT+0x3a>
    78e0:	e1 30       	cpi	r30, 0x01	; 1
    78e2:	c8 f0       	brcs	.+50     	; 0x7916 <DIO_INIT+0x64>
    78e4:	e2 30       	cpi	r30, 0x02	; 2
    78e6:	09 f0       	breq	.+2      	; 0x78ea <DIO_INIT+0x38>
    78e8:	49 c0       	rjmp	.+146    	; 0x797c <DIO_INIT+0xca>
    78ea:	2e c0       	rjmp	.+92     	; 0x7948 <DIO_INIT+0x96>
		case DIO_PIN_DIRECTION_OUTPUT:
			SET_BIT(*Reg[Port_Id], Pin_Id % 8);
    78ec:	e2 2f       	mov	r30, r18
    78ee:	f0 e0       	ldi	r31, 0x00	; 0
    78f0:	ee 0f       	add	r30, r30
    78f2:	ff 1f       	adc	r31, r31
    78f4:	e0 56       	subi	r30, 0x60	; 96
    78f6:	ff 4f       	sbci	r31, 0xFF	; 255
    78f8:	01 90       	ld	r0, Z+
    78fa:	f0 81       	ld	r31, Z
    78fc:	e0 2d       	mov	r30, r0
    78fe:	20 81       	ld	r18, Z
    7900:	87 70       	andi	r24, 0x07	; 7
    7902:	90 70       	andi	r25, 0x00	; 0
    7904:	a7 01       	movw	r20, r14
    7906:	02 c0       	rjmp	.+4      	; 0x790c <DIO_INIT+0x5a>
    7908:	44 0f       	add	r20, r20
    790a:	55 1f       	adc	r21, r21
    790c:	8a 95       	dec	r24
    790e:	e2 f7       	brpl	.-8      	; 0x7908 <DIO_INIT+0x56>
    7910:	24 2b       	or	r18, r20
    7912:	20 83       	st	Z, r18
    7914:	33 c0       	rjmp	.+102    	; 0x797c <DIO_INIT+0xca>
			break;
		case DIO_PIN_DIRECTION_INPUT_PULL_UP:
			CLEAR_BIT(*Reg[Port_Id], Pin_Id % 8);
    7916:	e2 2f       	mov	r30, r18
    7918:	f0 e0       	ldi	r31, 0x00	; 0
    791a:	ee 0f       	add	r30, r30
    791c:	ff 1f       	adc	r31, r31
    791e:	e0 56       	subi	r30, 0x60	; 96
    7920:	ff 4f       	sbci	r31, 0xFF	; 255
    7922:	01 90       	ld	r0, Z+
    7924:	f0 81       	ld	r31, Z
    7926:	e0 2d       	mov	r30, r0
    7928:	20 81       	ld	r18, Z
    792a:	87 70       	andi	r24, 0x07	; 7
    792c:	90 70       	andi	r25, 0x00	; 0
    792e:	a7 01       	movw	r20, r14
    7930:	02 c0       	rjmp	.+4      	; 0x7936 <DIO_INIT+0x84>
    7932:	44 0f       	add	r20, r20
    7934:	55 1f       	adc	r21, r21
    7936:	8a 95       	dec	r24
    7938:	e2 f7       	brpl	.-8      	; 0x7932 <DIO_INIT+0x80>
    793a:	ca 01       	movw	r24, r20
    793c:	80 95       	com	r24
    793e:	82 23       	and	r24, r18
    7940:	80 83       	st	Z, r24
			DIO_WRITE_PIN_VALUE(Pin_Id, DIO_PIN_STATE_HIGH);
    7942:	81 2f       	mov	r24, r17
    7944:	61 e0       	ldi	r22, 0x01	; 1
    7946:	18 c0       	rjmp	.+48     	; 0x7978 <DIO_INIT+0xc6>
			break;
		case DIO_PIN_DIRECTION_INPUT_FLOAT:
			CLEAR_BIT(*Reg[Port_Id], Pin_Id % 8);
    7948:	e2 2f       	mov	r30, r18
    794a:	f0 e0       	ldi	r31, 0x00	; 0
    794c:	ee 0f       	add	r30, r30
    794e:	ff 1f       	adc	r31, r31
    7950:	e0 56       	subi	r30, 0x60	; 96
    7952:	ff 4f       	sbci	r31, 0xFF	; 255
    7954:	01 90       	ld	r0, Z+
    7956:	f0 81       	ld	r31, Z
    7958:	e0 2d       	mov	r30, r0
    795a:	20 81       	ld	r18, Z
    795c:	87 70       	andi	r24, 0x07	; 7
    795e:	90 70       	andi	r25, 0x00	; 0
    7960:	a7 01       	movw	r20, r14
    7962:	02 c0       	rjmp	.+4      	; 0x7968 <DIO_INIT+0xb6>
    7964:	44 0f       	add	r20, r20
    7966:	55 1f       	adc	r21, r21
    7968:	8a 95       	dec	r24
    796a:	e2 f7       	brpl	.-8      	; 0x7964 <DIO_INIT+0xb2>
    796c:	ca 01       	movw	r24, r20
    796e:	80 95       	com	r24
    7970:	82 23       	and	r24, r18
    7972:	80 83       	st	Z, r24
			DIO_WRITE_PIN_VALUE(Pin_Id, DIO_PIN_STATE_LOW);
    7974:	81 2f       	mov	r24, r17
    7976:	60 e0       	ldi	r22, 0x00	; 0
    7978:	0e 94 27 3c 	call	0x784e	; 0x784e <DIO_WRITE_PIN_VALUE>
void DIO_INIT(void)
{
	DIO_PIN_ID_t Pin_Id;
	DIO_PORT_ID_t Port_Id;
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { DDRA_ADD, DDRB_ADD, DDRC_ADD, DDRD_ADD };
	for (Pin_Id = DIO_PINA0; Pin_Id < DIO_MAX_PINS; Pin_Id++) {
    797c:	1f 5f       	subi	r17, 0xFF	; 255
    797e:	21 96       	adiw	r28, 0x01	; 1
    7980:	c0 32       	cpi	r28, 0x20	; 32
    7982:	d1 05       	cpc	r29, r1
    7984:	09 f0       	breq	.+2      	; 0x7988 <DIO_INIT+0xd6>
    7986:	a0 cf       	rjmp	.-192    	; 0x78c8 <DIO_INIT+0x16>
		break;
		default:
			break;
		}
	}
}
    7988:	df 91       	pop	r29
    798a:	cf 91       	pop	r28
    798c:	1f 91       	pop	r17
    798e:	ff 90       	pop	r15
    7990:	ef 90       	pop	r14
    7992:	08 95       	ret

00007994 <DIO_READ_PIN_VALUE>:
	default:
		break;
	}
}
/****************************************************************************/
DIO_PIN_STATE_t DIO_READ_PIN_VALUE(const DIO_PIN_ID_t PIN_ID){
    7994:	28 2f       	mov	r18, r24
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { PINA_ADD, PINB_ADD, PINC_ADD, PIND_ADD };
	DIO_PORT_ID_t Port_Id = PIN_ID / 8;
	DIO_PIN_STATE_t State = DIO_PIN_STATE_LOW;
	if(DIO_PIN_STATE_HIGH == GET_BIT(*Reg[Port_Id], PIN_ID % 8)){
    7996:	e8 2f       	mov	r30, r24
    7998:	e6 95       	lsr	r30
    799a:	e6 95       	lsr	r30
    799c:	e6 95       	lsr	r30
    799e:	f0 e0       	ldi	r31, 0x00	; 0
    79a0:	ee 0f       	add	r30, r30
    79a2:	ff 1f       	adc	r31, r31
    79a4:	e0 57       	subi	r30, 0x70	; 112
    79a6:	ff 4f       	sbci	r31, 0xFF	; 255
    79a8:	01 90       	ld	r0, Z+
    79aa:	f0 81       	ld	r31, Z
    79ac:	e0 2d       	mov	r30, r0
    79ae:	80 81       	ld	r24, Z
    79b0:	90 e0       	ldi	r25, 0x00	; 0
    79b2:	27 70       	andi	r18, 0x07	; 7
    79b4:	02 c0       	rjmp	.+4      	; 0x79ba <DIO_READ_PIN_VALUE+0x26>
    79b6:	95 95       	asr	r25
    79b8:	87 95       	ror	r24
    79ba:	2a 95       	dec	r18
    79bc:	e2 f7       	brpl	.-8      	; 0x79b6 <DIO_READ_PIN_VALUE+0x22>
		State = DIO_PIN_STATE_HIGH;
	}
	return State;
}
    79be:	81 70       	andi	r24, 0x01	; 1
    79c0:	08 95       	ret

000079c2 <DIO_WRITE_PORT>:
/****************************************************************************/
void DIO_WRITE_PORT(const DIO_PORT_ID_t PORT_ID, const UINT8_t VALUE){
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { PORTA_ADD, PORTB_ADD, PORTC_ADD, PORTD_ADD };
	*Reg[PORT_ID] = VALUE;
    79c2:	e8 2f       	mov	r30, r24
    79c4:	f0 e0       	ldi	r31, 0x00	; 0
    79c6:	ee 0f       	add	r30, r30
    79c8:	ff 1f       	adc	r31, r31
    79ca:	e8 57       	subi	r30, 0x78	; 120
    79cc:	ff 4f       	sbci	r31, 0xFF	; 255
    79ce:	01 90       	ld	r0, Z+
    79d0:	f0 81       	ld	r31, Z
    79d2:	e0 2d       	mov	r30, r0
    79d4:	60 83       	st	Z, r22
}
    79d6:	08 95       	ret

000079d8 <DIO_Read_PORT>:
/****************************************************************************/
UINT8_t DIO_Read_PORT(const DIO_PORT_ID_t PORT_ID){
	volatile UINT8_t* const Reg[DIO_MAX_PORTS] = { PINA_ADD, PINB_ADD, PINC_ADD, PIND_ADD };
	return *Reg[PORT_ID];
    79d8:	e8 2f       	mov	r30, r24
    79da:	f0 e0       	ldi	r31, 0x00	; 0
    79dc:	ee 0f       	add	r30, r30
    79de:	ff 1f       	adc	r31, r31
    79e0:	e0 58       	subi	r30, 0x80	; 128
    79e2:	ff 4f       	sbci	r31, 0xFF	; 255
    79e4:	01 90       	ld	r0, Z+
    79e6:	f0 81       	ld	r31, Z
    79e8:	e0 2d       	mov	r30, r0
    79ea:	80 81       	ld	r24, Z
}
    79ec:	08 95       	ret

000079ee <boot_program_page>:
#include "util/delay.h"
#include "FLASHER.h"

void
boot_program_page (UINT32_t page, UINT8_t *buf)
{
    79ee:	ff 92       	push	r15
    79f0:	0f 93       	push	r16
    79f2:	1f 93       	push	r17
    79f4:	cf 93       	push	r28
    79f6:	df 93       	push	r29
    79f8:	8b 01       	movw	r16, r22
    79fa:	9c 01       	movw	r18, r24
    79fc:	da 01       	movw	r26, r20
	UINT8_t sreg;
	UINT32_t address;
	UINT16_t word ;

	// Disable interrupts.
	GIC;
    79fe:	8f b7       	in	r24, 0x3f	; 63
    7a00:	8f 77       	andi	r24, 0x7F	; 127
    7a02:	8f bf       	out	0x3f, r24	; 63
	sreg = SREG;
    7a04:	ff b6       	in	r15, 0x3f	; 63
	address = page * PAGE_SIZE ;


	boot_page_erase_safe (address);
    7a06:	07 b6       	in	r0, 0x37	; 55
    7a08:	00 fc       	sbrc	r0, 0
    7a0a:	fd cf       	rjmp	.-6      	; 0x7a06 <boot_program_page+0x18>
    7a0c:	e1 99       	sbic	0x1c, 1	; 28
    7a0e:	fe cf       	rjmp	.-4      	; 0x7a0c <boot_program_page+0x1e>
    7a10:	87 e0       	ldi	r24, 0x07	; 7
    7a12:	00 0f       	add	r16, r16
    7a14:	11 1f       	adc	r17, r17
    7a16:	22 1f       	adc	r18, r18
    7a18:	33 1f       	adc	r19, r19
    7a1a:	8a 95       	dec	r24
    7a1c:	d1 f7       	brne	.-12     	; 0x7a12 <boot_program_page+0x24>
    7a1e:	a8 01       	movw	r20, r16
    7a20:	83 e0       	ldi	r24, 0x03	; 3
    7a22:	f8 01       	movw	r30, r16
    7a24:	80 93 57 00 	sts	0x0057, r24
    7a28:	e8 95       	spm
    7a2a:	f8 01       	movw	r30, r16
	{
		// Set up little Endian word.
		word  = *buf++;
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
    7a2c:	11 e0       	ldi	r17, 0x01	; 1
	address = page * PAGE_SIZE ;


	boot_page_erase_safe (address);

	for (i=0; i<PAGE_SIZE; i+=2)
    7a2e:	ba 01       	movw	r22, r20
    7a30:	60 58       	subi	r22, 0x80	; 128
    7a32:	7f 4f       	sbci	r23, 0xFF	; 255
	{
		// Set up little Endian word.
		word  = *buf++;
    7a34:	9c 91       	ld	r25, X
		word += (*buf++) << 8;
    7a36:	11 96       	adiw	r26, 0x01	; 1
    7a38:	8c 91       	ld	r24, X
    7a3a:	11 97       	sbiw	r26, 0x01	; 1
#include "util/delay.h"
#include "FLASHER.h"

void
boot_program_page (UINT32_t page, UINT8_t *buf)
{
    7a3c:	12 96       	adiw	r26, 0x02	; 2
	{
		// Set up little Endian word.
		word  = *buf++;
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
    7a3e:	07 b6       	in	r0, 0x37	; 55
    7a40:	00 fc       	sbrc	r0, 0
    7a42:	fd cf       	rjmp	.-6      	; 0x7a3e <boot_program_page+0x50>
    7a44:	e1 99       	sbic	0x1c, 1	; 28
    7a46:	fe cf       	rjmp	.-4      	; 0x7a44 <boot_program_page+0x56>
    7a48:	38 2f       	mov	r19, r24
    7a4a:	20 e0       	ldi	r18, 0x00	; 0
    7a4c:	e9 01       	movw	r28, r18
    7a4e:	c9 0f       	add	r28, r25
    7a50:	d1 1d       	adc	r29, r1
    7a52:	0e 01       	movw	r0, r28
    7a54:	10 93 57 00 	sts	0x0057, r17
    7a58:	e8 95       	spm
    7a5a:	11 24       	eor	r1, r1
    7a5c:	32 96       	adiw	r30, 0x02	; 2
	address = page * PAGE_SIZE ;


	boot_page_erase_safe (address);

	for (i=0; i<PAGE_SIZE; i+=2)
    7a5e:	e6 17       	cp	r30, r22
    7a60:	f7 07       	cpc	r31, r23
    7a62:	41 f7       	brne	.-48     	; 0x7a34 <boot_program_page+0x46>
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
	}

	boot_page_write_safe (address);     // Store buffer in flash page.
    7a64:	07 b6       	in	r0, 0x37	; 55
    7a66:	00 fc       	sbrc	r0, 0
    7a68:	fd cf       	rjmp	.-6      	; 0x7a64 <boot_program_page+0x76>
    7a6a:	e1 99       	sbic	0x1c, 1	; 28
    7a6c:	fe cf       	rjmp	.-4      	; 0x7a6a <boot_program_page+0x7c>
    7a6e:	85 e0       	ldi	r24, 0x05	; 5
    7a70:	fa 01       	movw	r30, r20
    7a72:	80 93 57 00 	sts	0x0057, r24
    7a76:	e8 95       	spm

	// Reenable RWW-section again. We need this if we want to jump back
	// to the application after bootloading.

	boot_rww_enable_safe();
    7a78:	07 b6       	in	r0, 0x37	; 55
    7a7a:	00 fc       	sbrc	r0, 0
    7a7c:	fd cf       	rjmp	.-6      	; 0x7a78 <boot_program_page+0x8a>
    7a7e:	e1 99       	sbic	0x1c, 1	; 28
    7a80:	fe cf       	rjmp	.-4      	; 0x7a7e <boot_program_page+0x90>
    7a82:	81 e1       	ldi	r24, 0x11	; 17
    7a84:	80 93 57 00 	sts	0x0057, r24
    7a88:	e8 95       	spm

	// Re-enable interrupts (if they were ever enabled).

	SREG = sreg;
    7a8a:	ff be       	out	0x3f, r15	; 63
	GIE;
    7a8c:	8f b7       	in	r24, 0x3f	; 63
    7a8e:	80 68       	ori	r24, 0x80	; 128
    7a90:	8f bf       	out	0x3f, r24	; 63
}
    7a92:	df 91       	pop	r29
    7a94:	cf 91       	pop	r28
    7a96:	1f 91       	pop	r17
    7a98:	0f 91       	pop	r16
    7a9a:	ff 90       	pop	r15
    7a9c:	08 95       	ret

00007a9e <FLASH_Data_Write>:
#include "FLASH_DATA.h"
void
FLASH_Data_Write(UINT16_t Address, UINT8_t Data)
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEMWE))
    7a9e:	e2 99       	sbic	0x1c, 2	; 28
    7aa0:	fe cf       	rjmp	.-4      	; 0x7a9e <FLASH_Data_Write>
	;
	/* Set up address and data registers */
	EEAR = Address;
    7aa2:	9f bb       	out	0x1f, r25	; 31
    7aa4:	8e bb       	out	0x1e, r24	; 30
	EEDR = Data;
    7aa6:	6d bb       	out	0x1d, r22	; 29
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
    7aa8:	e2 9a       	sbi	0x1c, 2	; 28
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
    7aaa:	e1 9a       	sbi	0x1c, 1	; 28
}
    7aac:	08 95       	ret

00007aae <FLASH_Data_Read>:
UINT8_t
FLASH_Data_Read(UINT16_t Address)
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEMWE))
    7aae:	e2 99       	sbic	0x1c, 2	; 28
    7ab0:	fe cf       	rjmp	.-4      	; 0x7aae <FLASH_Data_Read>
	;
	/* Set up address register */
	EEAR = Address;
    7ab2:	9f bb       	out	0x1f, r25	; 31
    7ab4:	8e bb       	out	0x1e, r24	; 30
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    7ab6:	e0 9a       	sbi	0x1c, 0	; 28
	/* Return data from data register */
	return EEDR;
    7ab8:	8d b3       	in	r24, 0x1d	; 29
}
    7aba:	08 95       	ret

00007abc <Display_Page>:

	return AppIsFlashed;
}

void
Display_Page(UINT8_t*Data){
    7abc:	1f 93       	push	r17
    7abe:	cf 93       	push	r28
    7ac0:	df 93       	push	r29
    7ac2:	ec 01       	movw	r28, r24
    7ac4:	10 e0       	ldi	r17, 0x00	; 0
	UINT8_t i;
	for (i = 0; i < PAGE_SIZE; ++i) {
		URT_Tx_Char(Data[i]);
    7ac6:	fe 01       	movw	r30, r28
    7ac8:	e1 0f       	add	r30, r17
    7aca:	f1 1d       	adc	r31, r1
    7acc:	80 81       	ld	r24, Z
    7ace:	0e 94 6b 3e 	call	0x7cd6	; 0x7cd6 <URT_Tx_Char>
}

void
Display_Page(UINT8_t*Data){
	UINT8_t i;
	for (i = 0; i < PAGE_SIZE; ++i) {
    7ad2:	1f 5f       	subi	r17, 0xFF	; 255
    7ad4:	10 38       	cpi	r17, 0x80	; 128
    7ad6:	b9 f7       	brne	.-18     	; 0x7ac6 <Display_Page+0xa>
		URT_Tx_Char(Data[i]);
	}
}
    7ad8:	df 91       	pop	r29
    7ada:	cf 91       	pop	r28
    7adc:	1f 91       	pop	r17
    7ade:	08 95       	ret

00007ae0 <PARSER_Record>:
void
Display_Page(UINT8_t*Data);

BOOL_t
PARSER_Record(UINT8_t*Data, UINT8_t*Record)
{
    7ae0:	af 92       	push	r10
    7ae2:	bf 92       	push	r11
    7ae4:	df 92       	push	r13
    7ae6:	ef 92       	push	r14
    7ae8:	ff 92       	push	r15
    7aea:	0f 93       	push	r16
    7aec:	df 93       	push	r29
    7aee:	cf 93       	push	r28
    7af0:	00 d0       	rcall	.+0      	; 0x7af2 <PARSER_Record+0x12>
    7af2:	cd b7       	in	r28, 0x3d	; 61
    7af4:	de b7       	in	r29, 0x3e	; 62
    7af6:	7c 01       	movw	r14, r24
    7af8:	5b 01       	movw	r10, r22
	UINT8_t j = 0;
	BOOL_t AppIsFlashed = FALSE;
	/*check if there is received record*/

	/*check if record hex file ended*/
	if (0x01 == Asci2Hex(Record[6], Record[7])) {
    7afa:	fb 01       	movw	r30, r22
    7afc:	86 81       	ldd	r24, Z+6	; 0x06
    7afe:	67 81       	ldd	r22, Z+7	; 0x07
    7b00:	0e 94 b1 3b 	call	0x7762	; 0x7762 <Asci2Hex>
    7b04:	81 30       	cpi	r24, 0x01	; 1
    7b06:	21 f5       	brne	.+72     	; 0x7b50 <PARSER_Record+0x70>
		/*check if there is reminder record bytes */
		if (Idx_Data > 0) {
    7b08:	80 91 31 01 	lds	r24, 0x0131
    7b0c:	88 23       	and	r24, r24
    7b0e:	39 f4       	brne	.+14     	; 0x7b1e <PARSER_Record+0x3e>
    7b10:	1d c0       	rjmp	.+58     	; 0x7b4c <PARSER_Record+0x6c>
			/*fill reminder bytes with oxff value*/
			while (Idx_Data < PAGE_SIZE) {
				Data[Idx_Data] = 0xff;
    7b12:	f7 01       	movw	r30, r14
    7b14:	e8 0f       	add	r30, r24
    7b16:	f1 1d       	adc	r31, r1
    7b18:	90 83       	st	Z, r25
    7b1a:	8f 5f       	subi	r24, 0xFF	; 255
    7b1c:	01 c0       	rjmp	.+2      	; 0x7b20 <PARSER_Record+0x40>
    7b1e:	9f ef       	ldi	r25, 0xFF	; 255
	/*check if record hex file ended*/
	if (0x01 == Asci2Hex(Record[6], Record[7])) {
		/*check if there is reminder record bytes */
		if (Idx_Data > 0) {
			/*fill reminder bytes with oxff value*/
			while (Idx_Data < PAGE_SIZE) {
    7b20:	87 ff       	sbrs	r24, 7
    7b22:	f7 cf       	rjmp	.-18     	; 0x7b12 <PARSER_Record+0x32>
    7b24:	80 93 31 01 	sts	0x0131, r24
			Display_Page(Data);
#endif


			/*Flash code*/
			boot_program_page(NO_Pages, Data);
    7b28:	60 91 2f 01 	lds	r22, 0x012F
    7b2c:	70 91 30 01 	lds	r23, 0x0130
    7b30:	80 e0       	ldi	r24, 0x00	; 0
    7b32:	90 e0       	ldi	r25, 0x00	; 0
    7b34:	a7 01       	movw	r20, r14
    7b36:	0e 94 f7 3c 	call	0x79ee	; 0x79ee <boot_program_page>

			++NO_Pages;
    7b3a:	80 91 2f 01 	lds	r24, 0x012F
    7b3e:	90 91 30 01 	lds	r25, 0x0130
    7b42:	01 96       	adiw	r24, 0x01	; 1
    7b44:	90 93 30 01 	sts	0x0130, r25
    7b48:	80 93 2f 01 	sts	0x012F, r24
    7b4c:	81 e0       	ldi	r24, 0x01	; 1
    7b4e:	41 c0       	rjmp	.+130    	; 0x7bd2 <PARSER_Record+0xf2>
		}
		AppIsFlashed = TRUE;
	} else if (0x00 == Asci2Hex(Record[6], Record[7])) {
    7b50:	f5 01       	movw	r30, r10
    7b52:	86 81       	ldd	r24, Z+6	; 0x06
    7b54:	67 81       	ldd	r22, Z+7	; 0x07
    7b56:	0e 94 b1 3b 	call	0x7762	; 0x7762 <Asci2Hex>
    7b5a:	88 23       	and	r24, r24
    7b5c:	c9 f5       	brne	.+114    	; 0x7bd0 <PARSER_Record+0xf0>
		/*store current record size*/
		Record_Size = Asci2Hex(Record[0], Record[1]);
    7b5e:	f5 01       	movw	r30, r10
    7b60:	80 81       	ld	r24, Z
    7b62:	61 81       	ldd	r22, Z+1	; 0x01
    7b64:	0e 94 b1 3b 	call	0x7762	; 0x7762 <Asci2Hex>
    7b68:	d8 2e       	mov	r13, r24
    7b6a:	00 e0       	ldi	r16, 0x00	; 0
    7b6c:	2d c0       	rjmp	.+90     	; 0x7bc8 <PARSER_Record+0xe8>
		/*extract data from the recorder*/
		for (Idx_Record = 0; Idx_Record < Record_Size; ++Idx_Record) {
			Data[Idx_Data] = Asci2Hex(Record[j + 8], Record[j + 9]);
    7b6e:	80 91 31 01 	lds	r24, 0x0131
    7b72:	97 01       	movw	r18, r14
    7b74:	28 0f       	add	r18, r24
    7b76:	31 1d       	adc	r19, r1
    7b78:	3a 83       	std	Y+2, r19	; 0x02
    7b7a:	29 83       	std	Y+1, r18	; 0x01
    7b7c:	f5 01       	movw	r30, r10
    7b7e:	e9 0f       	add	r30, r25
    7b80:	f1 1d       	adc	r31, r1
    7b82:	80 85       	ldd	r24, Z+8	; 0x08
    7b84:	61 85       	ldd	r22, Z+9	; 0x09
    7b86:	0e 94 b1 3b 	call	0x7762	; 0x7762 <Asci2Hex>
    7b8a:	e9 81       	ldd	r30, Y+1	; 0x01
    7b8c:	fa 81       	ldd	r31, Y+2	; 0x02
    7b8e:	80 83       	st	Z, r24
			//	UDR=Data[Idx_Data];
			//	_delay_ms(1000);
			++Idx_Data;
    7b90:	80 91 31 01 	lds	r24, 0x0131
    7b94:	8f 5f       	subi	r24, 0xFF	; 255
    7b96:	80 93 31 01 	sts	0x0131, r24
			if (PAGE_SIZE == Idx_Data) {
    7b9a:	80 38       	cpi	r24, 0x80	; 128
    7b9c:	a1 f4       	brne	.+40     	; 0x7bc6 <PARSER_Record+0xe6>
#if 0
				Display_Page(Data);
#endif

				/*Flash code*/
				boot_program_page(NO_Pages, Data);
    7b9e:	60 91 2f 01 	lds	r22, 0x012F
    7ba2:	70 91 30 01 	lds	r23, 0x0130
    7ba6:	80 e0       	ldi	r24, 0x00	; 0
    7ba8:	90 e0       	ldi	r25, 0x00	; 0
    7baa:	a7 01       	movw	r20, r14
    7bac:	0e 94 f7 3c 	call	0x79ee	; 0x79ee <boot_program_page>
				Idx_Data = 0;
    7bb0:	10 92 31 01 	sts	0x0131, r1
				++NO_Pages;
    7bb4:	80 91 2f 01 	lds	r24, 0x012F
    7bb8:	90 91 30 01 	lds	r25, 0x0130
    7bbc:	01 96       	adiw	r24, 0x01	; 1
    7bbe:	90 93 30 01 	sts	0x0130, r25
    7bc2:	80 93 2f 01 	sts	0x012F, r24
		AppIsFlashed = TRUE;
	} else if (0x00 == Asci2Hex(Record[6], Record[7])) {
		/*store current record size*/
		Record_Size = Asci2Hex(Record[0], Record[1]);
		/*extract data from the recorder*/
		for (Idx_Record = 0; Idx_Record < Record_Size; ++Idx_Record) {
    7bc6:	0f 5f       	subi	r16, 0xFF	; 255
    7bc8:	90 2f       	mov	r25, r16
    7bca:	99 0f       	add	r25, r25
    7bcc:	0d 15       	cp	r16, r13
    7bce:	78 f2       	brcs	.-98     	; 0x7b6e <PARSER_Record+0x8e>
    7bd0:	80 e0       	ldi	r24, 0x00	; 0
			j += 2;
		}
	}

	return AppIsFlashed;
}
    7bd2:	0f 90       	pop	r0
    7bd4:	0f 90       	pop	r0
    7bd6:	cf 91       	pop	r28
    7bd8:	df 91       	pop	r29
    7bda:	0f 91       	pop	r16
    7bdc:	ff 90       	pop	r15
    7bde:	ef 90       	pop	r14
    7be0:	df 90       	pop	r13
    7be2:	bf 90       	pop	r11
    7be4:	af 90       	pop	r10
    7be6:	08 95       	ret

00007be8 <RECORD_Get>:


static UINT8_t Record[MAX_RECORD_SIZE];

UINT8_t*
RECORD_Get(void){
    7be8:	cf 93       	push	r28
    7bea:	df 93       	push	r29
    7bec:	c0 e0       	ldi	r28, 0x00	; 0
    7bee:	d0 e0       	ldi	r29, 0x00	; 0
	UINT8_t Character;
	UINT16_t i=0;

	do {
		Character = URT_Rx_Char();
    7bf0:	0e 94 67 3e 	call	0x7cce	; 0x7cce <URT_Rx_Char>
		if (Character != ':') {
    7bf4:	8a 33       	cpi	r24, 0x3A	; 58
    7bf6:	e1 f3       	breq	.-8      	; 0x7bf0 <RECORD_Get+0x8>
			Record[i] = Character;
    7bf8:	fe 01       	movw	r30, r28
    7bfa:	ee 5c       	subi	r30, 0xCE	; 206
    7bfc:	fe 4f       	sbci	r31, 0xFE	; 254
    7bfe:	80 83       	st	Z, r24
			++i;
		}

	} while (Character != STOP_CHAR);
    7c00:	8e 32       	cpi	r24, 0x2E	; 46
    7c02:	11 f0       	breq	.+4      	; 0x7c08 <RECORD_Get+0x20>

	do {
		Character = URT_Rx_Char();
		if (Character != ':') {
			Record[i] = Character;
			++i;
    7c04:	21 96       	adiw	r28, 0x01	; 1
    7c06:	f4 cf       	rjmp	.-24     	; 0x7bf0 <RECORD_Get+0x8>
		}

	} while (Character != STOP_CHAR);

	return &Record[0];
}
    7c08:	82 e3       	ldi	r24, 0x32	; 50
    7c0a:	91 e0       	ldi	r25, 0x01	; 1
    7c0c:	df 91       	pop	r29
    7c0e:	cf 91       	pop	r28
    7c10:	08 95       	ret

00007c12 <UDS_Send_Negative_Response>:
	URT_Tx_Char(UDS_POSITIVE_RESPONSE);
}

void
UDS_Send_Negative_Response(void){
	URT_Tx_Char(UDS_NEGATIVE_RESPONSE);
    7c12:	8d e2       	ldi	r24, 0x2D	; 45
    7c14:	0e 94 6b 3e 	call	0x7cd6	; 0x7cd6 <URT_Tx_Char>
}
    7c18:	08 95       	ret

00007c1a <UDS_Send_Positive_Response>:
	return Request;
}

void
UDS_Send_Positive_Response(void){
	URT_Tx_Char(UDS_POSITIVE_RESPONSE);
    7c1a:	8b e2       	ldi	r24, 0x2B	; 43
    7c1c:	0e 94 6b 3e 	call	0x7cd6	; 0x7cd6 <URT_Tx_Char>
}
    7c20:	08 95       	ret

00007c22 <UDS_Read_Request>:

	UDS_t Request = UDS_NO_REQ;

	UINT8_t Reading;

	Reading = FLASH_Data_Read(UDS_REQ_ADDRESS);
    7c22:	81 e0       	ldi	r24, 0x01	; 1
    7c24:	90 e0       	ldi	r25, 0x00	; 0
    7c26:	0e 94 57 3d 	call	0x7aae	; 0x7aae <FLASH_Data_Read>
    7c2a:	20 e1       	ldi	r18, 0x10	; 16
    7c2c:	37 e2       	ldi	r19, 0x27	; 39
    7c2e:	48 ec       	ldi	r20, 0xC8	; 200
    7c30:	50 e0       	ldi	r21, 0x00	; 0
    7c32:	fa 01       	movw	r30, r20
    7c34:	31 97       	sbiw	r30, 0x01	; 1
    7c36:	f1 f7       	brne	.-4      	; 0x7c34 <UDS_Read_Request+0x12>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7c38:	21 50       	subi	r18, 0x01	; 1
    7c3a:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7c3c:	d1 f7       	brne	.-12     	; 0x7c32 <UDS_Read_Request+0x10>

	_delay_ms(1000);

	switch (Reading) {
    7c3e:	80 33       	cpi	r24, 0x30	; 48
    7c40:	29 f0       	breq	.+10     	; 0x7c4c <UDS_Read_Request+0x2a>
    7c42:	80 3b       	cpi	r24, 0xB0	; 176
    7c44:	39 f0       	breq	.+14     	; 0x7c54 <UDS_Read_Request+0x32>
    7c46:	89 30       	cpi	r24, 0x09	; 9
    7c48:	19 f4       	brne	.+6      	; 0x7c50 <UDS_Read_Request+0x2e>
    7c4a:	06 c0       	rjmp	.+12     	; 0x7c58 <UDS_Read_Request+0x36>
    7c4c:	80 e3       	ldi	r24, 0x30	; 48
    7c4e:	08 95       	ret
    7c50:	88 ef       	ldi	r24, 0xF8	; 248
    7c52:	08 95       	ret
    7c54:	80 eb       	ldi	r24, 0xB0	; 176
    7c56:	08 95       	ret

	case UDS_CFG_BALANCE:

		Request = UDS_CFG_BALANCE;

		break;
    7c58:	89 e0       	ldi	r24, 0x09	; 9
	default:

		break;
	}
	return Request;
}
    7c5a:	08 95       	ret

00007c5c <UDS_Write_Request>:
#define UDS_REQ_ADDRESS 0x01

void
UDS_Write_Request(UDS_t Request){

	switch(Request){
    7c5c:	80 33       	cpi	r24, 0x30	; 48
    7c5e:	31 f0       	breq	.+12     	; 0x7c6c <UDS_Write_Request+0x10>
    7c60:	88 3f       	cpi	r24, 0xF8	; 248
    7c62:	49 f4       	brne	.+18     	; 0x7c76 <UDS_Write_Request+0x1a>

	case UDS_NO_REQ:
		FLASH_Data_Write(UDS_REQ_ADDRESS, UDS_NO_REQ);
    7c64:	81 e0       	ldi	r24, 0x01	; 1
    7c66:	90 e0       	ldi	r25, 0x00	; 0
    7c68:	68 ef       	ldi	r22, 0xF8	; 248
    7c6a:	03 c0       	rjmp	.+6      	; 0x7c72 <UDS_Write_Request+0x16>
		break;

	case UDS_REQ_DATA_TRANSFER:
		FLASH_Data_Write(UDS_REQ_ADDRESS, UDS_REQ_DATA_TRANSFER);
    7c6c:	81 e0       	ldi	r24, 0x01	; 1
    7c6e:	90 e0       	ldi	r25, 0x00	; 0
    7c70:	60 e3       	ldi	r22, 0x30	; 48
    7c72:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <FLASH_Data_Write>
    7c76:	80 e1       	ldi	r24, 0x10	; 16
    7c78:	97 e2       	ldi	r25, 0x27	; 39
    7c7a:	28 ec       	ldi	r18, 0xC8	; 200
    7c7c:	30 e0       	ldi	r19, 0x00	; 0
    7c7e:	f9 01       	movw	r30, r18
    7c80:	31 97       	sbiw	r30, 0x01	; 1
    7c82:	f1 f7       	brne	.-4      	; 0x7c80 <UDS_Write_Request+0x24>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7c84:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7c86:	d9 f7       	brne	.-10     	; 0x7c7e <UDS_Write_Request+0x22>

	}

	_delay_ms(1000);

}
    7c88:	08 95       	ret

00007c8a <URT_Rx>:
#include "STD_MEMORY_MAP.h"
#include "STD_BITS.h"
#include "URT.h"

void URT_Rx(const URT_MODE_t MODE){
	switch (MODE) {
    7c8a:	88 23       	and	r24, r24
    7c8c:	19 f0       	breq	.+6      	; 0x7c94 <URT_Rx+0xa>
    7c8e:	81 30       	cpi	r24, 0x01	; 1
    7c90:	21 f4       	brne	.+8      	; 0x7c9a <URT_Rx+0x10>
    7c92:	02 c0       	rjmp	.+4      	; 0x7c98 <URT_Rx+0xe>
	case URT_ENABLE:
		SET_BIT(UCSRB, 4);
    7c94:	54 9a       	sbi	0x0a, 4	; 10
    7c96:	08 95       	ret
		break;
	case URT_DISABLE:
		CLEAR_BIT(UCSRB, 4);
    7c98:	54 98       	cbi	0x0a, 4	; 10
    7c9a:	08 95       	ret

00007c9c <URT_Tx>:
		break;
	}
}
void URT_Tx(const URT_MODE_t MODE){
	switch (MODE) {
    7c9c:	88 23       	and	r24, r24
    7c9e:	19 f0       	breq	.+6      	; 0x7ca6 <URT_Tx+0xa>
    7ca0:	81 30       	cpi	r24, 0x01	; 1
    7ca2:	21 f4       	brne	.+8      	; 0x7cac <URT_Tx+0x10>
    7ca4:	02 c0       	rjmp	.+4      	; 0x7caa <URT_Tx+0xe>
	case URT_ENABLE:
		SET_BIT(UCSRB, 3);
    7ca6:	53 9a       	sbi	0x0a, 3	; 10
    7ca8:	08 95       	ret
		break;
	case URT_DISABLE:
		CLEAR_BIT(UCSRB, 3);
    7caa:	53 98       	cbi	0x0a, 3	; 10
    7cac:	08 95       	ret

00007cae <URT_Init>:
		break;
	}
}
void URT_Init(void){
	SET_BIT(UCSRC, 1);
    7cae:	80 b5       	in	r24, 0x20	; 32
    7cb0:	82 60       	ori	r24, 0x02	; 2
    7cb2:	80 bd       	out	0x20, r24	; 32
	SET_BIT(UCSRC, 2);
    7cb4:	80 b5       	in	r24, 0x20	; 32
    7cb6:	84 60       	ori	r24, 0x04	; 4
    7cb8:	80 bd       	out	0x20, r24	; 32
	UBRRH = URT_BAUD_RATE >> 8;
    7cba:	10 bc       	out	0x20, r1	; 32
	UBRRL = URT_BAUD_RATE;
    7cbc:	83 e3       	ldi	r24, 0x33	; 51
    7cbe:	89 b9       	out	0x09, r24	; 9

	/*enable full duplex mode*/
	URT_Tx(URT_ENABLE);
    7cc0:	80 e0       	ldi	r24, 0x00	; 0
    7cc2:	0e 94 4e 3e 	call	0x7c9c	; 0x7c9c <URT_Tx>
	URT_Rx(URT_ENABLE);
    7cc6:	80 e0       	ldi	r24, 0x00	; 0
    7cc8:	0e 94 45 3e 	call	0x7c8a	; 0x7c8a <URT_Rx>
}
    7ccc:	08 95       	ret

00007cce <URT_Rx_Char>:

UINT8_t URT_Rx_Char(void){
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<7)) )
    7cce:	5f 9b       	sbis	0x0b, 7	; 11
    7cd0:	fe cf       	rjmp	.-4      	; 0x7cce <URT_Rx_Char>
	;
	/* Get and return received data from buffer */
	return UDR;
    7cd2:	8c b1       	in	r24, 0x0c	; 12
}
    7cd4:	08 95       	ret

00007cd6 <URT_Tx_Char>:
void URT_Tx_Char(const UINT8_t CHAR){
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<5)) )
    7cd6:	5d 9b       	sbis	0x0b, 5	; 11
    7cd8:	fe cf       	rjmp	.-4      	; 0x7cd6 <URT_Tx_Char>
	;
	/* Put data into buffer, sends the data */
	UDR = CHAR;
    7cda:	8c b9       	out	0x0c, r24	; 12
}
    7cdc:	08 95       	ret

00007cde <main>:
#include "BOOTLOADER.h"

int
main(void){

	GIC;
    7cde:	8f b7       	in	r24, 0x3f	; 63
    7ce0:	8f 77       	andi	r24, 0x7F	; 127
    7ce2:	8f bf       	out	0x3f, r24	; 63
	DIO_INIT();
    7ce4:	0e 94 59 3c 	call	0x78b2	; 0x78b2 <DIO_INIT>
	URT_Init();
    7ce8:	0e 94 57 3e 	call	0x7cae	; 0x7cae <URT_Init>

	BOOTLOADER_Main();
    7cec:	0e 94 07 3a 	call	0x740e	; 0x740e <BOOTLOADER_Main>

	return 0;
}
    7cf0:	80 e0       	ldi	r24, 0x00	; 0
    7cf2:	90 e0       	ldi	r25, 0x00	; 0
    7cf4:	08 95       	ret

00007cf6 <_exit>:
    7cf6:	f8 94       	cli

00007cf8 <__stop_program>:
    7cf8:	ff cf       	rjmp	.-2      	; 0x7cf8 <__stop_program>
